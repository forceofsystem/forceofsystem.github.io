<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 生活之力</title>
    <link>https://forceoflife.cn/zh-cn/post/</link>
    <description>Recent content in Posts on 生活之力</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>Zhixiao-Zhang@outlook.com (Patrick)</managingEditor>
    <webMaster>Zhixiao-Zhang@outlook.com (Patrick)</webMaster>
    <lastBuildDate>Fri, 28 Jun 2024 21:50:46 +0800</lastBuildDate><atom:link href="https://forceoflife.cn/zh-cn/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机组成拾遗--CPU 如何更快地运行程序？</title>
      <link>https://forceoflife.cn/zh-cn/post/jsjzcysjsy/</link>
      <pubDate>Fri, 28 Jun 2024 21:50:46 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/jsjzcysjsy/</guid>
      
      <description>&lt;p&gt;我校的计算机组成原理课的正式名字为：计算机组成原理与体系结构，然而讲授的内容却更多偏向组成原理，体系结构的部分只是讲了最简单的流水线部分的知识。所以我在大二时买了《计算机组成与设计——软件硬件接口》的 MIPS 版打算学习，只读了指令和编码的部分。上个学期又买了 RISC-V 版，也没有来得及看，正好最近在做 GCC RISC-V 后端的工作，自觉在阅读《Computer Architecture: A Quantitive Approach》前应该读一读这本书，便索性画了 3 天连读带写，将书中的内容写成一份博客分享出来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中文译版质量太低，我怀疑是老师手底下的英语没过六级的研究生用 Word 翻译的QAQ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-如何度量计算机的性能&#34;&gt;1. 如何度量计算机的性能&lt;/h2&gt;
&lt;p&gt;要想让程序运行得快，最简单的方式就是买一台更好、更快的计算机，可如何比较不同计算机的速度呢？你可能认为，只需要计算出程序运行花费了多少秒，或者多少微秒然后比大小就可以了。但我们的目的是要让计算机上运行的程序跑得更快，这种粗粒度的比较方式并不能给我们提供什么有用的信息，所以我们必须要找到一种更具有参考价值的度量方法。&lt;/p&gt;
&lt;p&gt;一般而言，计算机通过时钟来确定各类事件在硬件中何时发生，这些离散的时间间隔被称为时钟周期数，也就是一个时钟周期的长度。我们还可以使用时钟周期的倒数——时钟频率（如 4 GHZ）。&lt;/p&gt;
&lt;p&gt;我们通常用如下方法来统计程序的 （CPU）执行时间：&lt;/p&gt;
&lt;p&gt;$$程序的\ CPU\ 执行时间 = 程序的\ CPU\ 时钟周期数  \times 时钟周期长度$$&lt;/p&gt;
&lt;p&gt;进一步地，拥有了程序的 CPU 时钟周期数，我们就能以此来计算指令的性能：&lt;/p&gt;
&lt;p&gt;$$CPU\ 时钟周期数 = 程序的指令数 \times 指令平均周期数$$&lt;/p&gt;
&lt;p&gt;指令平均周期数（clock cycle per instruction）表示执行每条指令所需的时钟周期平均数，缩写为 &lt;strong&gt;CPI&lt;/strong&gt;，这也是我们度量计算机性能的主要指标，我们正是用它来比较不同处理器的性能。&lt;/p&gt;
&lt;h2 id=&#34;2-程序可以比想象快流水线&#34;&gt;2. 程序可以比想象快：流水线&lt;/h2&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/image-20240628223216681.png&#34; alt=&#34;计算机的组成部件&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;我们可以把计算机认为是一个工厂，我们将原材料送进工厂，工厂给我们提供我们想要的产品，而计算机这个工厂的工人就是 CPU。如何让工厂能够更高效地生产呢，让我们回忆一下在初中历史课本上学到了什么。没错，我猜你和我一样想到了福特，就是福特汽车的创始人——亨利·福特，就是他在汽车制造的工厂中引入了流水线，从而获得了商业上的巨大成功。那我们能不能在计算机这个工厂中引入流水线，让 CPU 像福特公司的工人一样工作呢？&lt;/p&gt;
&lt;p&gt;当然可以。&lt;/p&gt;
&lt;p&gt;流水线的核心理念是把任务划分成多个步骤，某一个生产单位只负责一个步骤的工作，从而提高生产效率。我们同样可以将处理器也分为多个步骤，例如，常见的 RISC-V 指令的执行过程通常包括以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从存储器中取出指令。&lt;/li&gt;
&lt;li&gt;读取寄存器并译码。&lt;/li&gt;
&lt;li&gt;执行操作或计算地址。&lt;/li&gt;
&lt;li&gt;访问数据存储器中的操作数（如有必要）。&lt;/li&gt;
&lt;li&gt;将结果写入寄存器（如有必要）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我们将 CPU 执行指令的过程分成上面五步后，显然我们会有这样一个流水线：&lt;/p&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/image-20240628224814773.png&#34; alt=&#34;image-20240628224814773&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;流水线带来的性能提升可以归结为一个公式：&lt;/p&gt;
&lt;p&gt;$$指令执行时间_{流水线} = \frac{指令执行时间_{非流水线}}{流水线级数}$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理想条件下，流水线带来的加速比约等于流水线级数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了更好地利用流水线，我们可以在设计指令集时加入一些额外的设计，比如 RISC-V：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有指令长度相同。&lt;/li&gt;
&lt;li&gt;只有几种指令格式，源寄存器和目标寄存器字段的位置相同。&lt;/li&gt;
&lt;li&gt;存储器操作数只出现在 load 和 store 指令中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然流水线能带来很棒的性能提升，但它并非是没有代价的（又有什么是不付出代价就能得到的呢），这种代价就被称为——冒险（hazard）。&lt;/p&gt;
&lt;h3 id=&#34;21-流水线冒险&#34;&gt;2.1 流水线冒险&lt;/h3&gt;
&lt;p&gt;冒险是指下一条指令在下一个时钟周期中无法执行的情况。冒险共分为三种：结构冒险、数据冒险和控制冒险。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构冒险：硬件不支持多条指令在同一周期执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据冒险（流水线数据冒险）：无法提供指令执行所需数据而导致指令不能在预期的时钟周期内执行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;add x19, x0, x1
sub x2, x19, x3
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解决方法（前递或旁路）：向内部资源添加额外的硬件以找到缺少的运算项，使得不需要等待指令完成就尝试解决数据冒险。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;载入-使用型数据冒险：当载入指令要取的数据还没取回时，其他指令就需要该数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方法：流水线停顿（pipeline stall），俗称 bubble。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;lw&lt;/span&gt;  &lt;span style=&#34;color:#800&#34;&gt;x1&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;(&lt;span style=&#34;color:#800&#34;&gt;x31&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;lw&lt;/span&gt;  &lt;span style=&#34;color:#800&#34;&gt;x2&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;(&lt;span style=&#34;color:#800&#34;&gt;x31&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color:#800&#34;&gt;x3&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;x1&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;x2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;sw&lt;/span&gt;  &lt;span style=&#34;color:#800&#34;&gt;x3&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;24&lt;/span&gt;(&lt;span style=&#34;color:#800&#34;&gt;x31&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;lw&lt;/span&gt;  &lt;span style=&#34;color:#800&#34;&gt;x4&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;16&lt;/span&gt;(&lt;span style=&#34;color:#800&#34;&gt;x31&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color:#800&#34;&gt;x5&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;x1&lt;/span&gt;, &lt;span style=&#34;color:#800&#34;&gt;x4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;sw&lt;/span&gt;  &lt;span style=&#34;color:#800&#34;&gt;x5&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;32&lt;/span&gt;(&lt;span style=&#34;color:#800&#34;&gt;x31&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将 &lt;code&gt;lw x4, 16(x31)&lt;/code&gt; 移到第三行可以消除两个 &lt;code&gt;add&lt;/code&gt; 指令对其前一条 &lt;code&gt;lw&lt;/code&gt; 指令的依赖导致的冒险。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制冒险（分支冒险）：取到的指令不是需要的，或指令地址的流向不是流水线所预期的，导致正确的指令无法在正确的时钟周期内执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方法：
&lt;ul&gt;
&lt;li&gt;停顿：等待。&lt;/li&gt;
&lt;li&gt;预测：预测分支的结果并沿预测方向执行，而不是等分支结果确定后才开始执行。成熟的分支预测是预测一些条件分支指令发生跳转，另一些不发生。当预测错误时，流水线控制必须确保预测错误的条件分支指令之后的指令执行不会生效，并且从正确的分支地址处重新启动流水线。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态硬件预测器：根据每个条件分支的行为进行预测，结果在生命周期内可能改变。
&lt;ul&gt;
&lt;li&gt;常见实现方法：保存每个条件分支是否发生分支的历史记录根据最近的行为来预测未来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流水线级数之所以能够让程序跑得更快，是因为它挖掘了顺序指令流中的&lt;strong&gt;指令级并行性&lt;/strong&gt;，相对于多处理器编程，流水线的优点在于它对程序员是不可见的，换句话说，程序员无须操心是否能利用好流水线，这是编译器开发者需要费心的（没错，就是我QAQ……）。那么指令级并行性是什么呢？&lt;/p&gt;
&lt;h2 id=&#34;3-流水线背后指令级并行&#34;&gt;3. 流水线背后——指令级并行&lt;/h2&gt;
&lt;p&gt;指令级并行性（Instruction Level Parallelism，简称ILP）是指在计算机体系结构中，处理器能够同时执行多条没有数据依赖关系的指令的能力。&lt;/p&gt;
&lt;p&gt;有两种常见的提高指令级并行度的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;增加流水线级数，使更多的指令重叠执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多发射（multiple issue）：增加流水线内部的功能部件数量，使每周期发出多条指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前高端处理器的发射宽度为每周期 3 - 6 条指令，普通处理器的发射宽度一般为 2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推测：编译器或处理器“猜测”指令的行为，以尽早消除掉该指令与其他指令之间的依赖关系，可以由编译器实现（code schedule）或是由处理器硬件在动态执行时完成相同的操作，当推测错误时，需要将处理器恢复到推测前的状态。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预测分支结果，提早执行分支后的指令；&lt;/li&gt;
&lt;li&gt;对于先 &lt;code&gt;store&lt;/code&gt; 再 &lt;code&gt;load&lt;/code&gt; 的指令，可以预测两条指令访问的地址不同，同时提早执行 &lt;code&gt;load&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推测的问题也很明显：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现推测错误时的恢复机制比较困难；&lt;/li&gt;
&lt;li&gt;对某条指令的推测可能引入不必要的例外。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;增加流水线级数是一种很明显的方法，由于有更多的操作可以重叠执行，指令间的并行性自然更高。&lt;/p&gt;
&lt;p&gt;我们主要来看第二种方法，多发射。根据指令发射与否的判断所在的阶段可以将多发射分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态多发射：编译时判断&lt;/li&gt;
&lt;li&gt;动态多发射：动态执行过程中由硬件完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;31-静态多发射&#34;&gt;3.1 静态多发射&lt;/h3&gt;
&lt;p&gt;静态多发射处理器可以将同一周期发射出的指令集合（issue packet）看成一条需要进行多种操作的“大指令”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态多发射处理器通常会对同一周期发射的指令类型进行限制。将发射指令包看成一条预先定义好、需要进行多种操作的指令，这符合超长指令字（Very Long Instruction Word，VLIW）的设计思路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静态多发射由编译器来支持指令打包和处理冒险，编译器的任务主要有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态分支预测&lt;/li&gt;
&lt;li&gt;代码调度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态单发射处理器（尤其是超长指令字处理器）中，通常对同时发射的指令组合进行限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令需要成对&lt;/li&gt;
&lt;li&gt;指令地址需要 64 位对齐&lt;/li&gt;
&lt;li&gt;ALU 指令和分支指令放在前面&lt;/li&gt;
&lt;li&gt;如果指令对中的一条指令无法发射，需将其替换为 &lt;code&gt;nop&lt;/code&gt; 指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态单发射处理器解决冒险主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译器全部解决&lt;/li&gt;
&lt;li&gt;使用硬件来检测两个指令包间的数据冒险并产生相应的流水线停顿；编译器只负责解决单个指令包中的类型问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想同时发射 ALU 和数据传输指令，需要添加硬件以读写寄存器堆。因为 ALU 指令需要读取两个寄存器，store 指令可能需要读取两个以上的源寄存器；ALU 指令和 load 指令都需要更新一个目标寄存器，而 ALU 部件只负责计算 ALU 指令的执行，所以还需要额外增加一个加法器来进行地址的计算从而避免大量的结构冒险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;利用多发射以提高程序运行的例子：循环展开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反相关：由于名称服用而导致的顺序排列，并不是真正的数据相关（真相关）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-动态多发射处理器&#34;&gt;3.2 动态多发射处理器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态多发射处理器也称为超标量处理器或朴素的超标处理器，能够在硬件层面判断当前周期可以发射的指令数。&lt;/li&gt;
&lt;li&gt;超标量是一种高级流水线级数，指处理器能够在动态执行时选择指令，并在一个周期内执行一条以上的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;与超长指令字处理器的区别：不论是否需要编译器参与，超标量处理器都需要在硬件层面保证程序的正确性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;许多超标量处理器扩展了动态发射逻辑，演变为动态流水线调度技术：一种为避免停顿而对指令执行顺序进行重排的硬件技术。&lt;/p&gt;
&lt;p&gt;在基于动态流水线调度的处理器中，流水线被分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取指和发射单元：取指令、译码、将指令发送到各自的功能单元。&lt;/li&gt;
&lt;li&gt;多功能部件（高端处理器中数量多达十几个）：执行指令，将结果保存到提交单元。每一个功能单元都有若干保留站，用来存放指令的操作和所需的操作数。当指令所需的操作数和功能单元都就绪时，就可以执行指令，执行结果会被传送给保留站中正在等待使用该结果的指令，同时也传送到提交单元中进行保存。&lt;/li&gt;
&lt;li&gt;提交单元：保存已完成的指令的执行结果，在指令真正提交时用它们更新寄存器或写入内存。
&lt;ul&gt;
&lt;li&gt;提交单元的缓冲区被称为 &lt;strong&gt;reorder buffer&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/image-20240629162618560.png&#34; alt=&#34;image-20240629162618560&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;动态多发射处理器通过在保留站中保留操作数以及在重排序缓冲中保存运算结果，提供了一种类似寄存器重命名的技术：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发射指令时，指令会被拷贝到相应功能单元的保留站中，如果指令所需的操作数已准备好，也会从寄存器堆或者重排序缓冲中拷贝到保留站。对于处在发射阶段的指令，由于可用操作数都保存在保留站中，其在寄存器堆中的副本就没必要保存了，如果有操作需要堆该寄存器执行写操作，那么该寄存器的值就会被更新。&lt;/li&gt;
&lt;li&gt;如果操作数不在寄存器堆或者重排序缓冲中，那它一定在等待某个计算单元的计算结果，此时该计算单元的名字会被记录。当最终结果计算完毕后，将不会保存到寄存器堆，而是直接从功能单元拷贝到对应保留站中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种类似寄存器命名的技术，处理器可以在不违背程序原有数据流顺序的前提下以某种顺序执行指令，即&lt;strong&gt;乱序执行&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然在执行阶段，指令可以乱序执行，但为了保证程序行为和简单的按序单发射流水线一致，乱序执行流水线的取指和译码都需要按序进行，以便正确处理指令间的相关。提交阶段也需要按照取指的顺序依次将指令执行的结果写入寄存器和存储中，这种保守的处理方法被称为&lt;strong&gt;按序提交&lt;/strong&gt;。这样的好处是发生例外时处理器很容易就能找到例外前的最后一条指令，保证只更新这条指令之前的指令所写的寄存器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更高级的动态调度技术还包括基于硬件的推测式执行，尤其是基于分支预测的推测式执行。通过预测分支指令的转移方向来沿着预测路径不间断地取指和执行指令。这种方法的好处是在提交时，基于按序提交的提交单元可以保证在提交预测路径上的指令结果前就得知是否预测正确。这种方法还支持推测 &lt;code&gt;load&lt;/code&gt; 指令访问的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乱序执行会产生一些新的流水线冒险：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write-After-Read（WAR） 冒险&lt;/li&gt;
&lt;li&gt;Write-After-Write（WAW）冒险&lt;/li&gt;
&lt;li&gt;Read-After-Write（RAW）冒险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比于只用编译器通过指令调度来解决数据相关的问题，超标量处理器使用基于硬件实现的动态调度技术有以下几点优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不是所有的流水线停顿都是可预测的，特别是由于缓存失效带来的停顿就无法被预测到。&lt;/li&gt;
&lt;li&gt;只使用推测式执行技术去挖掘程序的指令级并行性会影响推测式执行的结果，例如频繁出现的例外。&lt;/li&gt;
&lt;li&gt;不同的流水线实现具有不同的延迟和发射宽度，动态调度技术可以隐藏这部分细节从而降低编译器的开发难度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-多发射存在的问题&#34;&gt;3.3 多发射存在的问题&lt;/h3&gt;
&lt;p&gt;虽然现代处理器可以通过多发射提高性能，但是保持高发射率是非常困难的。尽管存在四发射或六发射的处理器，但应用很难保持两条以上的发射率，原因主要有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令之间的依赖关系造成了流水线内部的性能瓶颈。很多时候这种依赖关系并不是真相关而是由于编译器和硬件的能力有限，如 C 语言中使用的指针，会产生存储器别名导致潜在的数据相关。也因此衍生出了静态分析中的别名分析（Alias Analysis）技术。&lt;/li&gt;
&lt;li&gt;存储层次中的缓存失效会使得流水线不能满负荷运转。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在挖掘了指令级并行性后，程序即使运行在一个处理器上也可以以一个可观的速度运行。那如何让程序更快呢？我们需要更多的处理器！&lt;/p&gt;
&lt;h2 id=&#34;4-程序还能更快并行&#34;&gt;4 程序还能更快：并行&lt;/h2&gt;
&lt;h3 id=&#34;41-并发与并行的区别&#34;&gt;4.1 并发与并行的区别&lt;/h3&gt;
&lt;p&gt;并发（current）和并行（parallel）一直是一个容易混淆的概念，其原因是两者的表现形式都是多个任务同时被执行。并发的反面是顺序，而并行的反面是串行。我们通常会使用操作系统来作为并发程序的例子，操作系统是一组进程互相写作来处理多个任务，因为操作系统是并发程序，所以可以在进程之间不断切换从而执行不同的任务，如果一个操作系统是顺序程序，那么就必须执行完一个任务再执行另一个任务；并发并不需要有多个处理器，它可以通过调度来制造拥有多个处理器的假象。而并行则不然，并行是指有多个处理器来完成任务，可以是任务级并行也可以是并行处理程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任务级并行：多个处理器完成多个独立的任务，也称为进程级并行。&lt;/p&gt;
&lt;p&gt;并行处理程序：多个处理器完成一个任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以用一张表格来区分并发、顺序、并行和串行：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;并行与并发&#34; src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/image-20240629182117366.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;42-创建并行处理程序的难点&#34;&gt;4.2 创建并行处理程序的难点&lt;/h3&gt;
&lt;p&gt;并行性的挑战在于，只有很少的应用程序能在被重写后在多处理器上更快地完成任务，因为很难利用多处理器来加速单个任务的运行，尤其是当处理器的数量增多时。造成这个问题主要有两个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多处理器上运行的并行处理程序必须获得更好的性能或更高的能效，而单处理器技术（如超标量和乱序执行）都充分利用了指令级并行，减少了多处理器重写程序的需求。&lt;/li&gt;
&lt;li&gt;处理器的增多，意味着需要将任务划分为更多可并行的部分、保证工作之间的负载均衡，解决更复杂的调度问题，尽可能减小同步时间并减小各部分间通信的开销。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第二个原因，我们还可以进一步考虑其影响因素：&lt;/p&gt;
&lt;p&gt;首先来复习一下 Amdahl 定律：&lt;/p&gt;
&lt;p&gt;$$优化后的时间 = \frac{受优化影响的执行时间}{优化量} + 不受优化影响的执行时间$$&lt;/p&gt;
&lt;p&gt;我们可以基于 Amdahl 定律给出加速比上的 Amdahl 定律：&lt;/p&gt;
&lt;p&gt;$$加速比 = \frac{改进前的执行时间}{改进前的执行时间 - 受优化影响的执行时间 + \frac{受优化影响的执行时间}{优化量}}$$&lt;/p&gt;
&lt;p&gt;为了进一步阐释这个公式，我们需要进行一些简单的计算：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：如果想在 100 个处理器上实现 90 倍的加速，那么原始计算中可以顺序执行的比例是多少？&lt;/p&gt;
&lt;p&gt;A：假设改进前的执行时间在某个单位时间内为 1，并且受优化影响的执行时间可以被视作与原始执行时间的比值，则有&lt;/p&gt;
&lt;p&gt;$$加速比 = \frac{1}{(1 - 受优化影响的执行时间比例) + \frac{受优化影响的执行时间比例}{优化量}}$$&lt;/p&gt;
&lt;p&gt;将优化量带入有：&lt;/p&gt;
&lt;p&gt;$$90 = \frac{1}{(1 - 受优化影响的执行时间比例) + \frac{受优化影响的执行时间比例}{100}}$$&lt;/p&gt;
&lt;p&gt;简化公式有：&lt;/p&gt;
&lt;p&gt;$$受优化影响的执行时间比例 = 89 / 89.1 = 0.999$$&lt;/p&gt;
&lt;p&gt;即为了在 100 个处理器上实现 90 倍的加速，顺序执行的程序部分最多占 0.1%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，如果一个程序想要充分利用很多核心，即使是该程序的很小一部分也需要进行改写，不幸的是有大量的应用程序都具有固有的并行性，也就是说我们想要改写程序有很大的工作量。为了了解这些固有的并行性从哪里来，我们不妨再进行一些简单的计算：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：对于如下两个加法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对 10 个标量变量的求和；&lt;/li&gt;
&lt;li&gt;一对 $10 \times 10$ 的二维数组求和；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若只有矩阵求和可以并行话，则使用 10 个和 40 个处理器能达到的加速比是多少？如果矩阵维数变为 $20 \times 20$ 呢？&lt;/p&gt;
&lt;p&gt;A：假设性能是加法程序所需时间 t 的函数，则加法程序在单个处理器上的运行时间是 110t，那么由 Amdahl 定律这个加法程序在 10 个处理器上的执行时间为：&lt;/p&gt;
&lt;p&gt;$$优化后的时间 = \frac{受优化影响的执行时间}{优化量} + 不受优化影响的执行时间 = \frac{100t}{10} + 10t = 20t$$&lt;/p&gt;
&lt;p&gt;则加速比为 5.5。&lt;/p&gt;
&lt;p&gt;在 40 个处理器上的执行时间为：&lt;/p&gt;
&lt;p&gt;$$优化后的时间 = \frac{受优化影响的执行时间}{优化量} + 不受优化影响的执行时间 = \frac{100t}{40} + 10t = 12.5t$$&lt;/p&gt;
&lt;p&gt;加速比为 8.8。&lt;/p&gt;
&lt;p&gt;在这个规模下，在 10 个处理器上获得了潜在加速比的大约 55%，在 40 个处理器上获得了潜在加速比的 22%。&lt;/p&gt;
&lt;p&gt;在矩阵规模增加后，响应的数据为 82% 和 51%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的计算告诉我们，保持问题规模不变的情况下在多处理器上获得良好的加速比相比于将问题规模放大的情况是更难的，因此为了区分这两种情况，我们引入了如下的两个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强比例缩放（strong scaling）：&lt;/li&gt;
&lt;li&gt;弱比例缩放（weak scaling）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容易想到，扩大问题规模会使处理器使用更多的内存，由此带来的缓存失效可能会干扰弱比例缩放的优势。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常来说，我们要根据应用程序的不同来选择不同的缩放方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，我们来看负载均衡对于加速比的影响：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：在上面的例子中，如果负载最重的处理器完成两倍负载（5%）和五倍负载（12.5%）时的加速比是多少，其他处理器的利用率如何？&lt;/p&gt;
&lt;p&gt;A：一个处理器需要完成 5% 的并行负载，则它要执行 $5% \times 400 = 20$ 次加法，另外的 39 个处理器将平分剩余的 380 次，由于计算是同时进行的，我们只需要计算两者时间的最大值：&lt;/p&gt;
&lt;p&gt;$$优化后的执行时间 = max(\frac{350t}{39},\frac{20t}{1}) + 10t = 30t$$&lt;/p&gt;
&lt;p&gt;加速比变为 14，其余 39 个处理器的使用时间不到负载最重的处理器的一半。&lt;/p&gt;
&lt;p&gt;同理，对于 12.5% 的负载，对应的加速比为 7，其余处理器的时间不到 20%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的计算证明了在编写并行程序时保证负载均衡的重要性。&lt;/p&gt;
&lt;h3 id=&#34;43-并行硬件分类和向量机&#34;&gt;4.3 并行硬件分类和向量机&lt;/h3&gt;
&lt;h4 id=&#34;431-向量与标量&#34;&gt;4.3.1 向量与标量&lt;/h4&gt;
&lt;p&gt;回忆一下我们在数学中学习过的标量和向量，&lt;strong&gt;标量（Scalar）&lt;strong&gt;只有大小，而向量既有大小又有方向。在计算机体系结构中，标量处理指的是对单个数据项进行操作。标量处理器是顺序操作的，即一次只处理一个数据元素，每次操作针对一个值；而向量处理则是同时对多个数据元素进行操作。在向量处理器中，一条指令可以应用于一组数据，这组数据就被称为&lt;/strong&gt;向量（Vector）&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;432-并行硬件分类&#34;&gt;4.3.2 并行硬件分类&lt;/h4&gt;
&lt;p&gt;在引入向量这个概念后，我们就可以分类并行硬件了，下面介绍的这种并行硬件分类方法自上世纪 60 年代提出后到今天仍在使用，该分类基于指令流数量和数据流数量。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;传统并行分类&#34; src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/image-20240629224026828.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;传统的单处理器具有单个指令流和单个数据流（即 SISD），传统的多处理器具有多个指令流和多个数据流（即 MIMD）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 MIMD 计算机上编程时，通常会编写一个运行在 MIMD 计算机中所有处理器的程序，不同处理器通过条件语句来执行对应的代码，这种风格称为&lt;strong&gt;单程序多数据流&lt;/strong&gt;（Single Program Multiple Data，&lt;strong&gt;SPMD&lt;/strong&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常，我们更喜欢 SIMD，即单指令流多数据流。SIMD 计算机对数据向量进行操作，如单个 SIMD 指令将 64 个数据流发送到 64 个 ALU 上以在单周期内完成 64 次加法来将 64 个数字相加。&lt;/p&gt;
&lt;p&gt;SIMD 的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIMD 计算机中所有的并行执行单元都是同步的，响应自同一程序计数器中发出的同一指令。尽管每个单元执行的指令是相同的，但是每个执行单元都有自己的地址寄存器，因此每个单元可以有自己的数据地址。&lt;/li&gt;
&lt;li&gt;减少了指令带宽和空间——SIMD 只需要各个处理器同时执行的代码的一个副本，消息传递类型的 MIMD 计算机可能需要在每个处理器中保存一个副本，而共享内存类型的 MIMD 计算机需要多个指令缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SIMD 在处理 for 循环中的数组时效果最好，在处理 switch 时效果最差。因此，为了在 SIMD 计算机上并行运行，程序中必须存在大量相同数据结构的数据，即&lt;strong&gt;数据级并行（data-level parallelism）&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;433-向量体系结构&#34;&gt;4.3.3 向量体系结构&lt;/h4&gt;
&lt;p&gt;向量体系结构的基本原理是从内存中手机数据元，将它们按顺序放入一大组寄存器（向量寄存器）中，使用流水化的执行单元在寄存器中对它们依次操作，将结果写回内存。&lt;/p&gt;
&lt;p&gt;下面我们来看一个向量体系结构并行的例子：&lt;/p&gt;
&lt;p&gt;DAXPY 是一个在数值计算和线性代数中常用的 BLAS 函数，它的全称是Double precision A times X Plus Y。DAXPY的主要功能是执行向量的线性组合，即计算一个向量与另一个向量的标量乘积再加到第三个向量上。数学上，对于两个实数向量x和y以及一个标量a，DAXPY执行以下操作：&lt;/p&gt;
&lt;p&gt;$$Y = a \times X + Y$$&lt;/p&gt;
&lt;p&gt;其中 X 和 Y 是 64 个双精度浮点数的向量，最初存储在内存中，a 是一个标量双精度变量。假设 X 和 Y 的起始地址分别存放在 x19 和  X20 ，传统的 RISC-V 代码为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;      fld		 f0, a(x3)     // 加载标量 a
      addi	 x5, x19, 512  // 计算数组 X 的边界，作为控制循环结束的条件
loop: fld		 f1, 0(x19)    // 加载 x[i]
      fmul.d f1, f1, f0    // 计算 a * x[i]
      fld		 f2, 0(x20)    // 加载 y[i]
      fadd.d f2, f2, f1    // 计算 a * x[i] + y[i]
      fsd    f2, 0(x20)    // 将结果保存到 y[i] 中
      addi	 x19, x19, 8   // 索引变量 x 自增
      addi	 x20, x20, 8   // 索引变量 y 自增
      bltu   x19, x5, loop // 继续循环
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设向量的单个元素长度是 64 位，我们可以写出如下基于 V 扩展的 RISC-V 代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;fld      f0, a(x3)   # 加载标量 a
vsetvli  x0, x0, e64 # 设置 64 位宽的元素
vle.v 	 v0, 0(x19)  # 加载向量 x
vfmul.vf v0, v0, f0  # 向量-标量乘法 a * x[i]
vle.v 	 v1, 0(x20)  # 加载向量 y
vfadd.vv v1, v1, v0  # 向量加法，计算a * x[i] + y[i]
vse.v    v1, 0(x20)  # 将结果存储到 y 中
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相比之下，向量处理器大大降低了指令带宽，相比于传统 RISC-V 体系结构的 500 条指令，向量 RISC-V 只需要 6 条指令就完成了任务。此外，向量处理器还降低了出现流水线冒险的频率，传统的 RISC-V 代码流水线停顿频率是向量版本的 64 倍，编译器可以使用循环展开来消除这种差异，但仍无法减少指令带宽的巨大差异。&lt;/p&gt;
&lt;h4 id=&#34;433-硬件多线程&#34;&gt;4.3.3 硬件多线程&lt;/h4&gt;
&lt;p&gt;硬件多线程与 MIMD 相关，MIMD 依赖于多个进程或线程来使多个处理器保持忙碌状态，而硬件多线程允许多个线程以重叠的方式共享单个处理器的功能单元以有效利用硬件资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理器必须复制每个线程的独立状态，如寄存器堆和程序计数器的独立副本。&lt;/li&gt;
&lt;li&gt;硬件需要具有在线程之间快速切换的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;硬件多线程的实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;细粒度多线程：在每条指令执行后切换线程（不包括在停顿的线程），从而达成多线程的交叉执行。
&lt;ul&gt;
&lt;li&gt;优点：可以隐藏由短期和长期停顿引起的吞吐量损失。&lt;/li&gt;
&lt;li&gt;缺点：减慢单个线程的执行速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;粗粒度多线程：仅在高开销的停顿上切换线程，如末级 cache 失效时。
&lt;ul&gt;
&lt;li&gt;优点：几乎不会减慢单个线程的执行速度。&lt;/li&gt;
&lt;li&gt;缺点：降低吞吐量的能力有限，特别是对于短停顿。因为粗粒度多线程处理器从单个线程发出指令，所以当停顿时必须清空或冻结流水线，新线程必须在造成停顿的指令完成前填充流水线，从而造成了流水线启动开销，当停顿较短时这种开销相对较大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于多发射处理器中具有大多数单线程难以充分利用的并行功能单元，所以衍生出了一种硬件多线程的变体，称为同时多线程（Simultaneous Multithreading, SMT），它使用多发射、动态调度流水线的处理器资源来挖掘线程级并行和指令级并行。通过寄存器重命名和动态调度技术，处理器可以不需要考虑依赖关系，发射多条来自相互独立线程的多条指令，通过动态调度来解决相关性的问题。&lt;/p&gt;
&lt;h4 id=&#34;435-多核和其他共享内存多处理器&#34;&gt;4.3.5 多核和其他共享内存多处理器&lt;/h4&gt;
&lt;p&gt;硬件多线程用很小的代价提升了处理器效率，但我们仍需要想办法有效利用单个芯片上不断增长的处理器核数量来发挥出摩尔定律呈现出的性能潜力。&lt;/p&gt;
&lt;p&gt;上文提到，重写就程序使其在并行硬件上高效运行是苦难的，所以我们可以尝试从计算机设计上来降低对应的难度。目前有两种主流的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为所有处理器提供一个共享的统一物理地址空间，使得程序无需考虑数据的存放位置，只需要考虑如何并行执行。&lt;/li&gt;
&lt;li&gt;为每个处理器采用独立的地址空间，但是在处理器间显式共享地址空间（硬件通常提供 cache 一致性以保证共享内存的一致性）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于第一种方法，共享内存多处理器（Shared Memory Processor，SMP）为所有处理器提供统一物理地址空间，处理器通过存储器中的共享变量进行通信，所有处理器都能通过 &lt;code&gt;load&lt;/code&gt; 和 &lt;code&gt;store&lt;/code&gt; 指令访问存储器的任意位置。&lt;/p&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/image-20240630004009431.png&#34; alt=&#34;共享内存多处理器&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;处理器仍可在自己的虚拟地址空间中独立运行程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单地址空间处理器有两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统一内存访问（UMA）多处理器：访问内存的延迟不依赖于提出请求的处理器。&lt;/li&gt;
&lt;li&gt;非统一内存访问（NUMA）多处理器：通过划分主存储器并分配给不同的处理器或同一芯片上的不同内存控制器，一些存储器的访问会比其他存储器快，这取决于处理器和其访问的存储器。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 NUMA 多处理器上编写并行程序的难度更高，但 NUMA 机器更容易扩大到更大规模，同时处理器访问附近的内存时比平均延迟更低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;处理器并行执行时通常需要共享数据，因此在操作共享数据时需要及时同步，也即需要一套独立的同步机制，通常而言是为共享变量提供锁。&lt;/p&gt;
&lt;p&gt;常用的共享内存多处理器编程模型是 OpenMP，它是一套支持共享内存多处理的 API，提供可以对标准编程语言进行扩展的编译器制导、环境变量和运行时库。但 OpenMP 的能力有限，所以也存在很多比 OpenMP 更复杂的并行编程系统。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MIMD 的另一常见硬件为 GPU，本文不作介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-结语&#34;&gt;5. 结语&lt;/h2&gt;
&lt;p&gt;通过不断地挖掘潜在的并行性，从指令级并行到真正的硬件级并行，CPU 让我们的程序运行得越来越快，而 GPU，特别是 GPGPU 和 DSA（Domain Specific Architect）似乎代表着未来的发展方向。如今，GPGPU 推动着人工智能行业迅猛发展，不知道未来的体系结构又会发生怎样的变化，让我们拭目以待吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;希望我能参与其中 QAQ。&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
    </item>
    
    <item>
      <title>围炉夜话（5）</title>
      <link>https://forceoflife.cn/zh-cn/post/wlyh5/</link>
      <pubDate>Fri, 10 May 2024 23:12:10 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/wlyh5/</guid>
      
      <description>&lt;p&gt;从打算动笔到正式动笔，已经过了近一个月。&lt;/p&gt;
&lt;p&gt;本打算雅思出成绩后就写的，又想想等拿到实习 offer 再写吧，这一等就是一个月。&lt;/p&gt;
&lt;p&gt;这一个月我过得不错，可以说是在学校最自在的一个月，雅思成绩还不错带来的喜悦仿佛很难消散。这一个月，我尝试着在宿舍自己做一点凉菜吃，虽然也有失败倒掉的经历，但大部分时候都能抚慰我水土不服的胃；这一个月，我积极面对生活，坚持跑步、控制饮食，明显感觉身体比之前健康很多，每天的精力也更足了；这一个月，我做自己喜欢的事情，加入了 PLCT 实验室的 GNU 小队，做一些 GCC 后端开发；这一个月的一切都很好，学院杯大家进了决赛，离冠军只有一步之遥。&lt;/p&gt;
&lt;p&gt;但其实改变的不止是这一个月，这一整个学期的我相较之前都更充实，或许是因为即将毕业不得已而为，抑或是目标明确带来的裨益。自从高考之后，我还没有参加过类似的用分数决定未来的考试，唯一不同的是，高考不会重来，雅思的机会有很多。可能是我心态使然，在准备考试的过程中越临近考试越放松，特别是听力和阅读稳定在 8 + 8.5 之后，更是随心所欲，只是随便看看口语，直到考试前一天才写了第一篇也是唯一一篇作文。&lt;/p&gt;
&lt;p&gt;不管怎样，雅思考试还是顺利通过了，7.0 + 5.5 的成绩也足以申请我想去的学校，不过这大概也是我最后一次参加这样用成绩换未来的考试了。准备雅思的过程中，我也见证了自己的成长，真正为了目之所及的未来去努力的感觉是高考也不曾有过的。从起初的 6.5 + 7 到最后的 8 + 8.5，这背后是 14 本剑雅的积累，也是我科学安排训练计划的结果。当然，这毕竟是一次重要的考试，说没有压力也是虚言，只是所幸感到压力、迷茫的时候有笑权和小朱姐帮我，尤其是笑权，这两个月来我几乎每天都会和他分享我备考的进度：每一篇听力和阅读的得分，每一次高分的喜悦、低分的失落以及原因，他也在不断地帮我缓解压力，在出分前焦虑时让我不要紧张。很难说如果没有笑权，我还能否如此顺利地通过考试。&lt;/p&gt;
&lt;p&gt;至于实习，雅思考完当天我就向 PLCT 投了简历，这是我早就想好的，我很想做一些 GCC 开发。经过机考和 mentor pick 之后，我拿到了我的第一份 offer，作为 PLCT 的一名实习生参与 GCC 开发。实习的内容和我想的很不一样，我原本想做的是优化方面的工作，但是实际做的都是一些后端相关的事，为 risc-v 指令集的各种扩展提供工具链支持。想想也是，AI  时代下编译器的绝大多数岗位应该都是硬件公司提供的，为自己的产品做支持。&lt;/p&gt;
&lt;p&gt;拿到 offer 的第一周，我还不能很好地平衡工作、学习和生活，把自己搞得疲惫不已，甚至还被传染了感冒。不过学校的课程马上就要结束了，之后就可以专心做自己的事，毕竟我的这场戏才刚刚开场，不管是实习、编译器比赛还是联系导师都还有很长的路要走。&lt;/p&gt;
&lt;p&gt;前文提到过，我最近的生活很健康，不过我好像又开始厌倦成都了，我在宿舍买了一堆调料用来拌凉菜，偶尔也买些卤味来下酒，上周末甚至买了六必居的炸酱和二八酱，只可惜并没有煮面的条件。有时候很想大吃几顿过过瘾，可一个人又吃不了什么，最多就是切些猪头肉罢了，酒也不能总喝，倒是饮料喝得没有之前多了，也是一件好事吧……&lt;/p&gt;
&lt;p&gt;在学校还要待近一个月，天气越来越热，我应该也越来越无心在此了，希望之后一切顺利罢。&lt;/p&gt;
&lt;p&gt;现在是凌晨一点十二分，已经很晚了，我也要休息了，也希望看到这篇文章的人都能健康顺遂。&lt;/p&gt;
&lt;p&gt;—— zzx 5 月 28 日凌晨一点十三分于江安西园宿舍床上&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>往事——评书</title>
      <link>https://forceoflife.cn/zh-cn/post/wangshi-pingshu/</link>
      <pubDate>Mon, 25 Dec 2023 23:52:00 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/wangshi-pingshu/</guid>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;今天是圣诞节，虽然我一向不喜过这国外的节日，但圣诞节与我却别有一番故事，故于今日记之。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“汉高祖刘邦斩蛇起义，建基立业！”&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
  &lt;img src=&#34;https://forceoflife.cn/2023/yuankuocheng.jpeg&#34; width=&#34;50%&#34; height=&#34;50%&#34;&gt;
&lt;/div&gt;
&lt;p&gt;熟悉评书的朋友肯定会立马想到，这是袁阔成先生的评书代表作《三国演义》中的第一句话，也是我对评书的第一记忆。我素来对传统曲艺很痴迷，对相声、评书、京韵大鼓、小曲小调抑或是京剧、秦腔都有所涉猎，这点我的朋友们都是知道的，但却很少有人知道我是什么时候对这些传统艺术产生兴趣的。一直有这样一个说法，天津人都会说相声。而之所以会产生这样的说法，大抵是因为虽然相声发源在北京天桥，但其兴盛却是在被称为“曲艺之乡”的天津，天津人或许不都会说相声，但打小都是听过相声的。很多人都无法想象，出租车里不放流行歌曲，却放着诸如《逗你玩》、《十点钟开始》、《买猴》这些上个世纪的相声是怎样一副光景。而我作为一个土生土长的内蒙人，自然是没有这样的经历，我直到高中时才算真正开始听相声，京剧、大鼓这些更是大学才开始接触；可唯独这评书，我却有着不输于天津朋友的听龄。&lt;/p&gt;
&lt;p&gt;应该是在 11 年或是 12 年的圣诞节（十余年前，恕我记不清了），那时我家还没有搬家，当我早上从温暖的被窝里爬出来时，天还没有亮，我早知那是圣诞节，便直接去枕头下摸索。那时的孩子应该大多都和我一样，最希望得到的礼物是动画片中的玩具，而我一摸之下，却没摸到什么玩具，心里有些失落的同时，手也摸到了薄薄的一个物件。将它拿出来后，上面写着“袁阔成评书系列”。彼时我尚不知评书为何物，更不晓得袁阔成是哪一位人物，便先搁置在一旁，赶忙去吃早饭准备上学了。&lt;/p&gt;
&lt;p&gt;已经记不得我是如何把那个玩意拆开，将里面的碟片放入 DVD 机的了，只知道当时第一次听的是三国，或许是因为我看过青少版的《三国演义》，却未曾读过《封神演义》的缘故吧。或许这就是大师区别于普通艺人的原因吧，当时听的第一句一直记到了现在，袁阔成老先生那富有穿透力的声音从四四方方的老式电视机中传出（那时我家还没有换液晶电视，还是那种老式的非常厚的电视机）。由于我从小就爱看书，对于评书这般，将书中内容讲给我听的形式也是很喜欢的，所以一有机会便要打开电视听评书。在那个年代（姑且将十年算作一个年代，毕竟 10 年到 20 年，也是发生了极大变化的），我家还没有什么新鲜的娱乐方式，父母的手机甚至还没有完全换成智能机，我母亲甚至可能还在用小灵通（也许已经从小灵通换成另一个普通手机了，但总归还不是智能机），父母下班为数不多的娱乐就是看看电视，所以我通常都是在白天听书，晚上就必须要让出电视，（现在已经完全回忆不起我那时在寒暑假都做些什么了）。我听完了三国，又听封神，听完封神，又听三国。当时的我把这两部书反反复复听了 5，6 遍，尤其是封神（因为封神很短）。后来我也问过我母亲为什么要给我买这个圣诞节礼物，她说当时只是想让我少玩些电脑。说起来我因为电脑而与父母的斗争史也是很有趣的，有机会也可以写一篇文章。这四张碟片我一直听了好多年，直到初一搬家才不再听了，而它们最后的归宿，应该也是被我母亲丢进垃圾桶中了罢；那时的我还不像现在这样时常怀念过去，自然也没有保留的念想。&lt;/p&gt;
&lt;p&gt;在五年级之前，我听的评书一直都是三国和封神，再没有别的书，最多是在小区里的大爷或是出租车师傅那里听到些单田芳单老的书。五年级的一天放学，因为和母亲出去办事时偶尔在车上听到一个电台里放评书，我把家里的收音机调到了 FM 98.1 包头文艺广播。那时应该是晚上7 点刚过，就听到收音机里放着一个武侠评书，我并不知道那是什么书，也不知道当时放到了哪里，甚至我开始可能都没怎么听懂，但我鬼使神差般地听了下来。到了 7 点 20，节目中间休息，我知道了这个节目叫《评书大联播》，这部书叫《冰川天女传》，是梁羽生先生的作品，说书人叫马长辉。这个节目每天 7 点开始，7 点 45 结束，中间有 5 分钟广告。从那天起，除非我要去上英语班、围棋班，或是身边没有收音机，我每天都会准时打开收音机收听节目，节目中间休息进广告之前会放一首歌，最初是一首西藏雪山风情的藏语歌，我和我母亲都非常喜欢听，只可惜直到现在我也不知道那首歌是什么；当时还没有听歌识曲的功能，我也没有想到可以把歌录下来，多年之后高二疫情在家时我还给 98.1 的公众号发消息问知不知道这首歌的名字，却被告知因为时间太久远了，他们也没有存档，不得不说是一件憾事。之后还放过一些歌，我有印象的就只有一首李玟的《月光爱人》，谁想到还不到十年，李玟竟不在人世了。可以说正是那时的《冰川天女传》，打开了我认识武侠世界的大门，这之后陆续放了中国第一部武侠小说，还珠楼主的《蜀山剑侠传》，古龙的《武林外史》，还有《冰川天女传》的续作《云海玉弓缘》。这之后我就上初中了，没有多少时间去听节目，加上这之后也不播武侠了，我便不再听了，但当时每天 7 点，我坐在旧居的小屋窗前的桌子边，一边写作业一边听评书的场景，却永远印在了我脑子里……&lt;/p&gt;
&lt;p&gt;初中搬家后，很长一段时间我很少听书了。这中间有几方面原因，一是我迷上了听音乐，尤其是英文歌，有些当时听的英文歌直到现在我也在听；二是初中学业相比小学却是要紧张不少；三是当时总是一壁写作业，一壁和她用 QQ 聊天，还要提防我妈进来突击检查我（我直到 17 年底才有自己的手机，之前我都是用需要搜题作藉口要来的手机）。总而言之，我很少听书了。偶尔不想听歌了，也只是打开懒人听书或蜻蜓FM（当时还没有喜马拉雅）搜一些刑侦探案（女法医刑侦记）或是军事（虎·解密神秘特种部队）相关的内容来听。当时我也没什么听评书的路子，只是听说有个网站叫“我听评书网”，网址是三w点5tps点com（这句是孙一先生当年的广告词），或是在车上听到广告推销评书机。到初三时，由于快要中考了，父母不再让我玩电脑，我也很少能拿到手机了，于是我就又想起了评书，但是苦于没有听书的渠道，于是我斥巨资从淘宝上买了一部评书机，里面有各位名家的评书，以单田芳单老的最多。也是在那时，我每天中午回家吃饭时，晚上不想做作业时都会打开评书机听书；也是在那时，我在《白眉大侠》中认识了徐良，从《三侠五义》中识得了南侠展昭、北侠欧阳春，了解了五鼠闹东京，从《大明演义》《明英烈》中知道了雌雄眼常茂等等……那时，评书又一次带给了我无穷的快乐。&lt;/p&gt;
&lt;p&gt;到了高中，由于有了自己的手机，我又很少听书了。那时喜马拉雅已经火了，我经常在喜马拉雅上收听悬疑探案小说，基本喜马拉雅所有的这类小说我都听过，还包括《古董局中局》、《鬼吹灯》等等。&lt;/p&gt;
&lt;p&gt;虽然很少听书，但我却开始表演评书了。那是高中的一次语文演讲，主题是讲成语。我一直抓心挠肝地想把一个通俗的成语故事讲出新意，这时，我突然想到了评书。于是，我将这个成语的故事找来，按照我的理解改成了评书，又学习单老的讲述方法，甚至单老那云遮月的嗓音（不得不说，我模仿能力还是很强的）。到了表演那天，我从家里带了初中时刻的石章当作醒木，上台开始念定场诗：“道德三皇五帝，功名夏侯商周，五霸七雄闹春秋，顷刻兴亡过手。青史几行名姓，北邙无数荒丘，前任撒种后人收，都道是龙争虎斗！”。言必一拍醒木，便博得满堂喝彩，那也是我最满意的一次演讲。&lt;/p&gt;
&lt;p&gt;大一开学不久，学院举行了文化衫活动，每班要出一个节目。由于我在自我介绍时说了一段单老的“张作霖手黑”，组织上便安排我去表演。到了台上，当我用单老的嗓音开场，台下也响起了掌声。虽然评书是北方，尤其是靠东地区的曲艺形式，但在这里，也同样能被人欣赏。又过了一年，22 年底，因为疫情我在 12 月初就回家了。那时的我正处于最低谷期，还没从被辩论压抑的一学期走出来，每天也无心上网课，每天中午吃过饭就出去散心。走在路上，我总觉得应该听些什么，但又找不出合适的歌曲，于是，我打开喜马拉雅，搜了一部单老的乱世枭雄来听，熟悉的节奏，熟悉的嗓音，抚慰了我的心灵，也让我唤起了我与评书的点点回忆。&lt;/p&gt;
&lt;p&gt;直到现在，我偶尔还会搜出袁阔成老先生的三国或是封神，来回味一下曾经的故事，回味一下那一去不返的少年锦时，我与评书的故事讲完了，但我这部书，还没开脸……&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>从零开始学 CPython - 0</title>
      <link>https://forceoflife.cn/zh-cn/post/python1/</link>
      <pubDate>Tue, 19 Dec 2023 14:28:43 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/python1/</guid>
      
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Python 是时下最流行的编程语言，在 &lt;a href=&#34;https://www.tiobe.com/tiobe-index/&#34;&gt;TIOBE&lt;/a&gt; 排行榜上连续多年位居榜首，作为一名计算机相关专业的学生，掌握 Python 是非常有必要的。可我还不会 CPython，真是闻着伤心见者落泪。于是我痛定思痛，打算新开一个系列，从零开始学习 CPython，努力成为一个会调包的合格大学生（误）。你可能注意到了我说我要从零开始学习 CPython，如果你对 CPython 不够了解的话，&lt;del&gt;CPython 是 Python 的别称，意思是像 C 一样快的 Python。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;好吧，玩笑到此就结束了，正式介绍一下，CPython 是 Python 解释器的官方实现，对于大多数人来说，平常写的 Python 代码就是由 CPython 来解释执行的。这个系列是我从零开始阅读 Python 源码，将编译原理、虚拟机等理论知识与工程上具体的实现相结合的尝试。&lt;/p&gt;
&lt;h2 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h2&gt;
&lt;h3 id=&#34;获取-cpython-源码&#34;&gt;获取 CPython 源码&lt;/h3&gt;
&lt;p&gt;既然是学习 Python 的源码，那么就有必要搭建一个环境来支持我们阅读、运行、修改源代码。在笔者写这篇文章时，Python 已经完全迁移到 Github 上开发了，可以用 git 将 CPython 的源码直接克隆到本地:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git clone https://github.com/python/cpython.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;笔者的电脑是一台 M1 芯片的 Macbook Air：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ uname -m -s
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Darwin arm64
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后可以运行下面的指令来编译 CPython:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./configure --with-pydebug &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;简单解释一下，&lt;code&gt;./configure --with-pydebug&lt;/code&gt; 是执行 &lt;a href=&#34;https://www.gnu.org/software/autoconf/&#34;&gt;GNU Autoconf&lt;/a&gt; 来生成 Makefile。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译完成后可以运行一下测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./python.exe -m &lt;span style=&#34;color:#a2f&#34;&gt;test&lt;/span&gt; -j3 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可能会奇怪为什么是 python.exe，这明明不是 Windows 系统。这是因为 Mac 系统是大小写不敏感的，如果不加后缀名的话会与目录中的 Python 目录冲突，加上 .exe 后缀可以避免这种情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ file python.exe
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;python.exe: Mach-O 64-bit executable arm64
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到了这里，你就成功拥有了一份完整的 CPython 源码，笔者使用的源码是 3.13.0a2+。如果你在编译中遇到了问题，你可以访问 Python 的&lt;a href=&#34;https://devguide.python.org&#34;&gt;开发者指导&lt;/a&gt;网站来获取不同操作系统的教程。&lt;/p&gt;
&lt;h3 id=&#34;阅读代码环境搭建&#34;&gt;阅读代码环境搭建&lt;/h3&gt;
&lt;p&gt;有了源码，接下来是如何阅读源码。对于 CPython 这个体量的项目，一般的工具肯定是不行的。所以，&lt;del&gt;我推荐大家使用 Notepad.exe。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;我没有尝试过将 CPython 的代码导入 IDE，但我猜这会吃掉我笔记本的所有内存并占用所有的 CPU 来建立索引。我无意挑起所谓的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Editor_war&#34;&gt;Editor War&lt;/a&gt;，我只是来分享一下我的方案。我使用 Vim + Clangd + Ctags + Ripgrep (rg) 来阅读代码，在 CPython 巨大的代码量下，LSP（Clangd）几乎失灵，我用 Ctags 建立了基本的索引，在无法跳转时，用 rg 搜索对应函数的位置（没有安装 rg 也可以用 grep）。不过有一点我觉得很重要，就是关闭 LSP 的 diagnostics 功能，不然你可能会看到“山河一片红”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你对我的 Vim 配置感兴趣，欢迎&lt;a href=&#34;https://github.com/forceofsystem/dotvim&#34;&gt;查看&lt;/a&gt;并送我一颗星星，顺带一提，我的配置很简洁而轻量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无论如何，不管你选择 Vim、Emacs、Source Insight、VSCode 或是使用其他 IDE，你的目标都是能够方便地查看代码，而不是像以前的我一样为了配置编辑器而配置编辑器～。&lt;/p&gt;
&lt;h3 id=&#34;调试环境搭建&#34;&gt;调试环境搭建&lt;/h3&gt;
&lt;p&gt;没错，你还需要一个调试器。当你捋不清函数的调用关系时，你需要打开调试器，查看调用栈来获取更多信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我在撰写本文时大量采用这种方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 上，你可以选择 GDB，因为 GDB 没有适配 M1，所以我选择了 LLDB，在 Windows 上，你可以选择 &lt;a href=&#34;https://www.mingw-w6b4.org&#34;&gt;MinGW64&lt;/a&gt; 自带的 GDB。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我的 LLDB 是通过 &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; 安装的，不是 &lt;code&gt;xcode-select --install&lt;/code&gt; 安装的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;python-学习基础&#34;&gt;Python 学习基础&lt;/h2&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;p&gt;在开始阅读源代码之前，我们先来了解一下 CPython 的目录结构。绝大多数 CPython 代码都在下面几个文件夹中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Include：头文件&lt;/li&gt;
&lt;li&gt;Objects：各种对象的实现&lt;/li&gt;
&lt;li&gt;Python：解释器、字节码编译器和其他重要的基础组件&lt;/li&gt;
&lt;li&gt;Parser：词法分析器、语法分析器以及语法分析生成器&lt;/li&gt;
&lt;li&gt;Modules：标准库模块以及 main.c&lt;/li&gt;
&lt;li&gt;Programs：包含了程序的入口函数 main()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你是在 Linux 或 BSD （不包括 Mac OS X），这就是与你有关的所有目录；而如果你在用 Mac 或者 Windows，还有以下目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mac：专用于 Mac OS X 的代码&lt;/li&gt;
&lt;li&gt;PC：专用于 Windows 的代码（旧）&lt;/li&gt;
&lt;li&gt;PCBuild：专用于 Windows 使用的 MSVC 的代码（新）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个系列的博客中，我们只关心公共部分的代码，而不会关注这些特定平台的代码。&lt;/p&gt;
&lt;h3 id=&#34;命名约定&#34;&gt;命名约定&lt;/h3&gt;
&lt;p&gt;在阅读之前，我们还需要学习一下 Python 的命名方式，根据 &lt;a href=&#34;https://peps.python.org/pep-0007/#naming-conventions&#34;&gt;PEP 7&lt;/a&gt; 中对于命名约定的说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除 static 函数外，对于所有的 public 函数，使用 &lt;code&gt;Py&lt;/code&gt; 作前缀；对于 global service routines，使用 &lt;code&gt;Py_&lt;/code&gt; 前缀，如 &lt;code&gt;Py_FatalError&lt;/code&gt;；对于特定类型的例程，使用与之相关的较长的前缀，如 &lt;code&gt;PyString_&lt;/code&gt; 之于字符串相关函数。&lt;/li&gt;
&lt;li&gt;public 函数和变量的命名混合使用大小写和下划线，如：&lt;code&gt;PyObject_GetAttr&lt;/code&gt;，&lt;code&gt;Py_BuildValue&lt;/code&gt;，&lt;code&gt;PyExc_TypeError&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;需要将 internal 的函数可见时，使用 &lt;code&gt;_Py&lt;/code&gt; 前缀，如：&lt;code&gt;_PyObject_Dump&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对于宏，其前缀是大小写混合，之后的部分全部使用大写，如：&lt;code&gt;PyString_AS_STRING&lt;/code&gt;，&lt;code&gt;Py_PRINT_RAW&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;宏参数应该使用 ALL_CAPS 风格，以便与变量和结构成员进行区分。
&lt;ul&gt;
&lt;li&gt;ALL_CAPS 风格：用下划线作分割，全部字母大写。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;学习开始&#34;&gt;学习开始&lt;/h2&gt;
&lt;h3 id=&#34;学习目标&#34;&gt;学习目标&lt;/h3&gt;
&lt;p&gt;下面我们就可以开始正式学习 CPython 的代码了，虽然我迫不及待地想看看 Python 是如何进行语法分析（Parse），Python 的虚拟机是如何实现的、采用了什么垃圾回收算法，但是俗话说：“心急吃不了热豆腐”，我们还是从一个简单的目标开始。&lt;/p&gt;
&lt;p&gt;现在在你的终端运行我们刚编译好的 Python，什么参数也不要加，就像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./python.exe
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Python 3.13.0a2+ &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;heads/main:21d52995ea&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;Clang 15.0.0 &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;clang-1500.0.40.1&lt;span style=&#34;color:#666&#34;&gt;)]&lt;/span&gt; on darwin
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Type &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;help&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;copyright&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;credits&amp;#34;&lt;/span&gt; or &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;license&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; more information.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们就进入了 Python 的 REPL(Read-Eval-Print-Loop) 模式，作为一个“第一次”使用 Python 的新人，我非常好奇这个 Header 和交互提示符（Prompt）是怎么被打出来的。所以，我决定先探寻一下 Python 是怎么跑起来的，又是怎么打出那个经典的提示符 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 的。&lt;/p&gt;
&lt;h3 id=&#34;找到入口&#34;&gt;找到入口&lt;/h3&gt;
&lt;p&gt;就想所有的 C 程序那样，CPython 也有一个入口函数，CPython 的入口函数位于 Programs 的 &lt;code&gt;python.c&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;argv)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;Py_BytesMain&lt;/span&gt;(argc, argv);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到这个函数调用了定义在 Modules/main.c 中的 &lt;code&gt;Py_BytesMain&lt;/code&gt; 函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;据 Guido 所说，main.c 不在 &lt;code&gt;Python&lt;/code&gt; 目录下而在 &lt;code&gt;Modules&lt;/code&gt; 目录下是由于一些不太重要的历史原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，在保存了命令行参数后，&lt;code&gt;Py_BytesMain&lt;/code&gt; 函数就调用了 &lt;code&gt;pymain_main&lt;/code&gt; 函数。在这个函数里，首先执行了对解释器的初始化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Py_BytesMain&lt;/code&gt; 是对 &lt;code&gt;Py_Main&lt;/code&gt; 的包装，用来防治因为 locale 和编码模式不同而导致的错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;初始化解释器&#34;&gt;初始化解释器&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;pymain_main&lt;/code&gt; 中，调用 &lt;code&gt;pymain_init&lt;/code&gt; 来初始化解释器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PyStatus status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_init&lt;/span&gt;(args);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先来看一下 &lt;code&gt;PyStatus&lt;/code&gt; 这个类型，根据 &lt;a href=&#34;https://peps.python.org/pep-0587/&#34;&gt;PEP587&lt;/a&gt;，其是用来存储初始化函数的状态，成功、错误或是退出，并且还会存储造成错误的函数名。简单看一下 &lt;code&gt;PyStatus&lt;/code&gt; 的字段组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exitcode&lt;/code&gt; (int): Argument passed to exit().&lt;/li&gt;
&lt;li&gt;&lt;code&gt;err_msg&lt;/code&gt; (const char*): Error message.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func&lt;/code&gt; (const char *): Name of the function which created an error, can be NULL.&lt;/li&gt;
&lt;li&gt;private &lt;code&gt;_type&lt;/code&gt; field: for internal usage only.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入 &lt;code&gt;pymain_init&lt;/code&gt; 函数，可以看到初始化包括三个部分：运行时、preconfig、config。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; PyStatus
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;pymain_init&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; _PyArgv &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PyStatus status;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyRuntime_Initialize&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PyPreConfig preconfig;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;PyPreConfig_InitPythonConfig&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;preconfig);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_Py_PreInitializeFromPyArgv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;preconfig, args);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PyConfig config;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;PyConfig_InitPythonConfig&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;config);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (args&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;use_bytes_argv) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyConfig_SetBytesArgv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;config, args&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;argc, args&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;bytes_argv);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyConfig_SetArgv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;config, args&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;argc, args&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;wchar_argv);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;Py_InitializeFromConfig&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;config);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyStatus_OK&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;代码省略了部分错误处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这对应着 &lt;a href=&#34;https://peps.python.org/pep-0432/&#34;&gt;PEP432&lt;/a&gt; 中提到的解释器初始化的三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 核心运行时预初始化（Python core runtime preinitiallization）:
&lt;ul&gt;
&lt;li&gt;启动内存管理；&lt;/li&gt;
&lt;li&gt;决定系统接口使用的编码；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Python 核心运行时初始化（Python core runtime initialization）:
&lt;ul&gt;
&lt;li&gt;确保 C API 已经可以使用；&lt;/li&gt;
&lt;li&gt;确保内置模块与冻结模块（&lt;code&gt;frozen&lt;/code&gt;）是可访问的；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主解释器配置（Main interpreter configuration）:
&lt;ul&gt;
&lt;li&gt;确保外部模块是可访问的；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 3.8 之前，初始化过程都是分为 2 步。CPython 的开发者们从 2012 年末到 2020 中期，用了 8 年的时间来重构，以让 Python 的启动过程更容易维护，同时也更容易嵌入到大型应用中。大家可以去阅读 PEP 432 和 PEP 587 来获取更完整的信息。
在现在的设计中，Python 的初始化过程分为以下四个阶段：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;未初始化：还未开始初始化过程；&lt;/li&gt;
&lt;li&gt;预初始化：解释器还不能使用；&lt;/li&gt;
&lt;li&gt;运行时已初始化：主解释器部分可用，还不能创建子解释器；&lt;/li&gt;
&lt;li&gt;初始化完成：主解释器完全可用，可以创建子解释器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Python 3.8 中，为上述步骤都添加了一些数据结构，我们可以在上面的代码中看到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PyPreConfig&lt;/code&gt; 结构体用来预初始化 Python 的下述功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置内存分配器；&lt;/li&gt;
&lt;li&gt;配置 LC_CTYPE locale；&lt;/li&gt;
&lt;li&gt;设置 UTF-8 模式；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上面的代码中可以看到与预初始化相关的函数：&lt;code&gt;PyPreConfig_InitPythonConfig&lt;/code&gt; 和 &lt;code&gt;Py_PreInitializeFromPyArgv&lt;/code&gt;，前者用来初始化默认配置（preconfiguration），后者则用来预初始化 Python。&lt;/p&gt;
&lt;p&gt;预初始化结束后，开始初始化。首先初始化默认配置，将命令行参数存储到 &lt;code&gt;config-&amp;gt;argv&lt;/code&gt;，之后调用 &lt;code&gt;Py_InitializeFromConfig&lt;/code&gt; 完成之后的初始化过程。&lt;code&gt;PyConfig&lt;/code&gt; 是一个相当庞大的结构体，其定义有足足 100 行之多。&lt;/p&gt;
&lt;h3 id=&#34;运行开始&#34;&gt;运行开始&lt;/h3&gt;
&lt;p&gt;在执行完初始化过程后，&lt;code&gt;pymain_main&lt;/code&gt; 函数调用了 &lt;code&gt;Py_RunMain&lt;/code&gt; 函数，终于要开始正式运行了，初始化过程可真是漫长，呜呼～。进入这个函数，它的代码意外地简单，我还以为会很复杂呢。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;Py_RunMain&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_python&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;exitcode);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#00a000&#34;&gt;Py_FinalizeEx&lt;/span&gt;() &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Value unlikely to be confused with a non-error exit status or
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           other special meaning */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;120&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;pymain_free&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (_PyRuntime.signals.unhandled_keyboard_interrupt) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;exit_sigint&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; exitcode;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;很容易发现，这个函数是对 &lt;code&gt;pymain_run_python&lt;/code&gt; 的一个包装，要想探究真正的运行过程，我们还需要继续抽丝剥茧地向里探查，&lt;code&gt;pymain_run_python&lt;/code&gt; 启动！&lt;/p&gt;
&lt;p&gt;一进入这个函数，这个近 100 行的函数体就让我感到头晕。跳过一些获取解释器状态的代码，我们看到这个函数首先加载了 &lt;code&gt;readline&lt;/code&gt; 模块,这个模块可以为我们提供获取输入的能力。&lt;code&gt;pymain_import_readling&lt;/code&gt; 函数是对 &lt;code&gt;PyImport_ImportModule&lt;/code&gt; 的封装，在这个函数里一共引入了两个模块，分别是 &lt;code&gt;readline&lt;/code&gt; 和 &lt;code&gt;rlcompleter&lt;/code&gt;，后者用于提供在交互式环境下的自动补全功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;pymain_import_readline&lt;/span&gt;(config);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PyObject &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;mod &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyImport_ImportModule&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;readline&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mod &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyImport_ImportModule&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;rlcompleter&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;让我们越过那些冗长的错误处理（虽然它们是必要的，但是对于梳理代码运行逻辑可真没什么用），我们看到了今天的第一个目标，&lt;code&gt;pymain_header&lt;/code&gt;，没错，这个函数会输出我们在进入 python repl 时显示的那几行关于版本的信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;Python %s on %s&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00a000&#34;&gt;Py_GetVersion&lt;/span&gt;(), &lt;span style=&#34;color:#00a000&#34;&gt;Py_GetPlatform&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;site_import) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, COPYRIGHT);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;COPYRIGHT 是一个定义在 main.c 中的宏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之后我们就会看到通往下一个阶段的大门，一个 if-else if-else 语句，用来调用不同运行模式下的函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_command) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_command&lt;/span&gt;(config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_command);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_module) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_module&lt;/span&gt;(config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_module, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (main_importer_path &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_module&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;L&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_filename &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_file&lt;/span&gt;(config);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_stdin&lt;/span&gt;(config);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为我们是在终端运行的，所以会进入到 &lt;code&gt;pymain_run_stdin&lt;/code&gt; 函数中去，跳过对能否交互和错误处理的部分，我们最终会进入到这一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; run &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyRun_AnyFileExFlags&lt;/span&gt;(stdin, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cf);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们不妨猜测一下，应该马上就要开始运行了。可以看出，这个函数是对标准输入和文件输入做了统一，当处于交互式模式（REPL）、用标准输入传递脚本文件（./python.exe &amp;lt; hello.py）或是正常的运行脚本文件时都可以使用这个函数。在对文件系统的编码进行转换后，这个函数继续调用 &lt;code&gt;_PyRun_AnyFileObject&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PyObject &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;filename_obj;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (filename &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        filename_obj &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyUnicode_DecodeFSDefault&lt;/span&gt;(filename);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (filename_obj &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#00a000&#34;&gt;PyErr_Print&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        filename_obj &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; res &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyRun_AnyFileObject&lt;/span&gt;(fp, filename_obj, closeit, flags);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个函数中，与运行直接相关的代码是下面这个条件语句：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; res;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#00a000&#34;&gt;_Py_FdIsInteractive&lt;/span&gt;(fp, filename)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        res &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyRun_InteractiveLoopObject&lt;/span&gt;(fp, filename, flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (closeit) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#00a000&#34;&gt;fclose&lt;/span&gt;(fp);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        res &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyRun_SimpleFileObject&lt;/span&gt;(fp, filename, closeit, flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于可交互环境，它会调用 &lt;code&gt;_PyRun_InteracticeLoopObject&lt;/code&gt; 函数，从命名就可以看出，这里面会包括一个循环用于不断进行交互；而如果是执行一个脚本文件，则会调用下面这个函数。因为我们的目标是找到 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 是在哪里输出的，所以我们继续进入上面这个函数。一进入这个函数，我们就看到了我们想要的东西：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PyObject &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;v &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PySys_GetAttr&lt;/span&gt;(tstate, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;_Py_ID&lt;/span&gt;(ps1));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (v &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;_PySys_SetAttr&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;_Py_ID&lt;/span&gt;(ps1), v &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyUnicode_FromString&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&amp;gt;&amp;gt;&amp;gt; &amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;Py_XDECREF&lt;/span&gt;(v);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    v &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PySys_GetAttr&lt;/span&gt;(tstate, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;_Py_ID&lt;/span&gt;(ps2));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (v &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;_PySys_SetAttr&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;_Py_ID&lt;/span&gt;(ps2), v &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyUnicode_FromString&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;... &amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;Py_XDECREF&lt;/span&gt;(v);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是的，我们看到了 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;，不过别急，离它被输出到终端模拟器还有好一段距离。这段代码将系统的提示符，&lt;code&gt;sys.ps1&lt;/code&gt; 和 &lt;code&gt;sys.ps2&lt;/code&gt; 分别设置为 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;...&lt;/code&gt;。由于对 sys 模块的属性操作非常频繁，所以有专门的辅助函数来完成设置，这两个函数定义在 Python 目录下的 sysmoudle.c 中。再往下看，我们果然看到了一个 do-while 循环，在 Guido 的教程里，我们可以看到最初使用的是 for 循环，不知道为什么改为了 do-while 循环，也许是使从无限循环用 break 跳出，do-while 循环结束的条件更清晰。在这个循环里，很明显我们需要关注下面这个函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ret &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyRun_InteractiveOneObjectEx&lt;/span&gt;(fp, filename, flags);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进入这个函数后，我一眼就看到了 &lt;code&gt;pyrun_one_parse_ast&lt;/code&gt; 和 &lt;code&gt;run_mod&lt;/code&gt;，根据我开发解释器的经验，前者是用来进行语法分析，建立 AST （Abstract Syntax Tree，抽象语法树）的，后者则是用来执行字节码的。据此，我对 Python 的编译器架构有了一定的猜测，Python 是用 Parser 来驱动 Lexer，而不是同一级别顺次执行。进入 &lt;code&gt;pyrun_one_parse_ast&lt;/code&gt; 函数，我们又看到了熟悉的 &lt;code&gt;sys.ps1&lt;/code&gt;、&lt;code&gt;sys.ps2&lt;/code&gt;，这个函数先设置了编码和两个提示符，之后作为参数传递给了 &lt;code&gt;_PyParser_InteractiveASTFromFile&lt;/code&gt; 函数，后者作为包装函数又调用了 &lt;code&gt;_PyPegen_run_parser_from_file_pointer&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;好深的调用关系qwq。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个名字超长的函数里，我注意到了几行关键代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tok_state &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;tok &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyTokenizer_FromFile&lt;/span&gt;(fp, enc, ps1, ps2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Parser &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyPegen_Parser_New&lt;/span&gt;(tok, start_rule, parser_flags, PY_MINOR_VERSION,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    errcode, arena);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    result &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyPegen_run_parser&lt;/span&gt;(p);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是说，CPython 是由 Parser 驱动 Tokenizer，Tokenizer 驱动 Lexer 的。第一行代码是获取一个 Tokenizer，第二行是创建一个新的 Parser，第三行则是执行这个 parser。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pegen 是 Parser generator 的缩写，与 Python Parser 的设计有关，之后的文章再写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们现在只想知道 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 是怎么来的，所以直接查看 &lt;code&gt;_PyPegen_run_parser&lt;/code&gt; 的代码，而这个函数是对 &lt;code&gt;_PyPegen_parse&lt;/code&gt; 的包装。在这个函数里，我们又看到了 if-else if-else 的代码结构来区分不同的执行方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;start_rule &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; Py_file_input) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;file_rule&lt;/span&gt;(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;start_rule &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; Py_single_input) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;interactive_rule&lt;/span&gt;(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;start_rule &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; Py_eval_input) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;eval_rule&lt;/span&gt;(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;start_rule &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; Py_func_type_input) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func_type_rule&lt;/span&gt;(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们是交互模式，所以进入 &lt;code&gt;interactive_rule&lt;/code&gt; 函数，发现里面有一块没有被条件语句或循环语句包围的作用域：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// statement_newline
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;error_indicator) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;level&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;D&lt;/span&gt;(&lt;span style=&#34;color:#00a000&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%*c&amp;gt; interactive[%d-%d]: %s&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;level, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;, _mark, p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;mark, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;statement_newline&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        asdl_stmt_seq&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            (a &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;statement_newline_rule&lt;/span&gt;(p))  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// statement_newline
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#00a000&#34;&gt;D&lt;/span&gt;(&lt;span style=&#34;color:#00a000&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%*c+ interactive[%d-%d]: %s succeeded!&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;level, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;, _mark, p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;mark, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;statement_newline&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            _res &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyAST_Interactive&lt;/span&gt; ( a , p &lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt; arena );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (_res &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyErr_Occurred&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;error_indicator &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;level&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;goto&lt;/span&gt; done;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;mark &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; _mark;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;D&lt;/span&gt;(&lt;span style=&#34;color:#00a000&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%*c%s interactive[%d-%d]: %s failed!&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;level, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;error_indicator &lt;span style=&#34;color:#666&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;ERROR!&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;, _mark, p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;mark, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;statement_newline&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;进入-tokenizer&#34;&gt;进入 Tokenizer&lt;/h3&gt;
&lt;p&gt;根据注释我们可以知道，这个作用域是用来处理新一行的。这里代码有些复杂，&lt;code&gt;D()&lt;/code&gt; 是一个宏，用来在调试模式下输出一些内容，分析一下可以发现，prompt 是在每一行的开头输出的，所以我们的目标应该是 &lt;code&gt;statement_newline_rule&lt;/code&gt; 函数。进入这个函数后，里面的内容印证了我前文中的猜测，Python 的 Tokenizer 是由 Parser 驱动的，理由就是这个函数：&lt;code&gt;_PyPegen_fill_token&lt;/code&gt;。从名字可以看出，这个函数是用来填充 token 来供 Parser 解析的，函数内的前三行代码也反映了这一功能：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; token new_token;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;_PyToken_Init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;new_token);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; type &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_PyTokenizer_Get&lt;/span&gt;(p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;tok, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;new_token);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;新建，初始化，获取一气呵成。因为目前为止还没有看到获取输入的部分，所以我们还没有触及到输出提示符的位置。而根据编译器的性质，直接获取输入的都是 lexer，所以我们需要继续向下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码真的好复杂呜呜。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入 &lt;code&gt;_PyTokenizer_Get&lt;/code&gt; 函数，发现其是对 &lt;code&gt;tok_get&lt;/code&gt; 的简单包装。后者对需要获取的 token 类型进行了判断，因为我们什么都没输入，所以不属于 f-string 类型，所以会调用 &lt;code&gt;tok_get_normal_mode&lt;/code&gt; 函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (current_tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;kind &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; TOK_REGULAR_MODE) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;tok_get_normal_mode&lt;/span&gt;(tok, current_tok, token);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;tok_get_fstring_mode&lt;/span&gt;(tok, current_tok, token);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;f-string 是 Python 的一种特性，支持格式化字符串。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;age &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;formatted_string &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;My name is &lt;/span&gt;&lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;{&lt;/span&gt;name&lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt; and I am &lt;/span&gt;&lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;{&lt;/span&gt;age&lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt; years old.&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;在函数中我们看到了一个无限的 for 循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; (;;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            c &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;tok_nextc&lt;/span&gt;(tok);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                col&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;, altcol&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;\t&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                col &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (col &lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt; tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;tabsize &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;tabsize;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                altcol &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (altcol &lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt; ALTTABSIZE &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; ALTTABSIZE;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;\014&amp;#39;&lt;/span&gt;)  {&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Control-L (formfeed) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                col &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; altcol &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* For Emacs users */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;\\&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                   &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; ((c &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;tok_continuation_line&lt;/span&gt;(tok)) &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;MAKE_TOKEN&lt;/span&gt;(ERRORTOKEN);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;很明显可以看出，这个循环是获取缩进的，因为 Python 是一个缩进敏感的语言，而 &lt;code&gt;tok_nextc&lt;/code&gt; 则很明显是我们接下来的目标。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;据 Guido 说，他把 Python 设计成这样是为了让程序员们能够好好格式化他们的代码，因为以前的编辑器自动格式化功能总是没办法使人满意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里面又是一个无限循环，与上同理，我们的关注目标是：&lt;code&gt;rc = tok-&amp;gt;underflow(tok);&lt;/code&gt;，rc 是我们获取的 token，而赋值右边的这个代码，如果你熟悉 C 语言的话就会认出，&lt;code&gt;tok-&amp;gt;underflow&lt;/code&gt; 是一个函数指针，它以 tok 作为参数调用了某个函数，那它究竟调用了哪个函数？&lt;/p&gt;
&lt;p&gt;因为 tok 的一个字段是函数指针，所以我们有必要回头关注一下 tok 的初始化过程。在 &lt;code&gt;_PyTokenizer_FromFile&lt;/code&gt; 中，tok-&amp;gt;underflow 被设置为了 &lt;code&gt;&amp;amp;tok_underflow_interactive&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (ps1 &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; ps2) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;underflow &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tok_underflow_interactive;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;underflow &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tok_underflow_file;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;这并不是一个 C 语言的教程，所以我假定你对函数指针有一定的了解，并简单使用过它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 &lt;code&gt;tok-&amp;gt;underflow(tok)&lt;/code&gt; 会调用 tok_underflow_interactive(tok)，而在这个函数中会调用 PyOS_Readline 函数，经过初始化和获取可读锁后，调用了 PyOS_StdioReadline 函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;tok_underflow_interactive&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;newtok &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyOS_Readline&lt;/span&gt;(tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;fp &lt;span style=&#34;color:#666&#34;&gt;?&lt;/span&gt; tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;fp&lt;/span&gt; : stdin, stdout, tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;prompt);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;PyOS_Readline&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (PyOS_ReadlineFunctionPointer &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PyOS_ReadlineFunctionPointer &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; PyOS_StdioReadline;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _PyOS_ReadlineTState &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; tstate;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Py_BEGIN_ALLOW_THREADS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;PyThread_acquire_lock&lt;/span&gt;(_PyOS_ReadlineLock, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;isatty&lt;/span&gt;(&lt;span style=&#34;color:#00a000&#34;&gt;fileno&lt;/span&gt;(sys_stdin)) &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;isatty&lt;/span&gt;(&lt;span style=&#34;color:#00a000&#34;&gt;fileno&lt;/span&gt;(sys_stdout)) &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;_Py_IsMainInterpreter&lt;/span&gt;(tstate&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;interp))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rv &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;PyOS_StdioReadline&lt;/span&gt;(sys_stdin, sys_stdout, prompt);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rv &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;PyOS_ReadlineFunctionPointer)(sys_stdin, sys_stdout, prompt);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里你可能会疑惑为什么需要一个条件判断，而且条件判断执行的内容还是一样的。据 Guido 所说，因为 PyOS_ReadlineFunctionPointer 是一个公开的 C api，所以可以编写一个 C 扩展来自定义它，这会方便那些希望 GUI 能够处理 python 输入的开发者来更好地将 python 嵌入到他们自己的程序中。更多信息可以查看 Guido 自己的教程。&lt;/p&gt;
&lt;p&gt;不论如何，我们都进入到了 PyOS_StdioReadline 函数里，跳过关于 Windows console 的宏，我们就看到了最终的目标：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;fflush&lt;/span&gt;(sys_stdout);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (prompt) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;fprintf&lt;/span&gt;(stderr, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, prompt);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;fflush&lt;/span&gt;(stderr);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到了这里，你可以长舒一口气了，不过 prompt 是在哪里被设置的呢？我们先追溯这个参数第一次被传入的位置，我们刚刚在寻找 &lt;code&gt;tok-&amp;gt;underflow&lt;/code&gt; 是何时被绑定的时，最终确定是在 &lt;code&gt;_PyTokenizer_FromFile&lt;/code&gt; 函数里，如果你观察仔细的话，你会发现它的上一行就是对提示符的赋值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;prompt &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ps1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  tok&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;nextprompt &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ps2;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;呜呼，所以我们知道了 Python 是如何初始化，REPL 中的 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 是怎么打出来的，多么寻常而又不寻常的一条 &lt;code&gt;fprintf&lt;/code&gt; 语句啊。那么这次的文章就到这里，之后我们可以再来看看 Python 是怎么运行起来的（lexer，tokenizer，parser）。&lt;/p&gt;
&lt;p&gt;等等，我还有一个疑问，就是在 &lt;code&gt;pymain_run_python&lt;/code&gt; 函数中的 if-else if-else 语句中：它的下面还有一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_command) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_command&lt;/span&gt;(config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_command);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_module) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_module&lt;/span&gt;(config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_module, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (main_importer_path &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_module&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;L&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (config&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;run_filename &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_file&lt;/span&gt;(config);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exitcode &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pymain_run_stdin&lt;/span&gt;(config);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00a000&#34;&gt;pymain_repl&lt;/span&gt;(config, exitcode);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其内部调用的是 &lt;code&gt;PyRun_AnyFileFlags&lt;/code&gt;，这个函数是 &lt;code&gt;pymain_run_stdin&lt;/code&gt; 调用的函数的一个宏包装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define PyRun_AnyFileFlags(fp, name, flags) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;    PyRun_AnyFileExFlags((fp), (name), 0, (flags))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是在 &lt;code&gt;pymain_run_stdin&lt;/code&gt; 中调用 &lt;code&gt;PyRun_AnyFileExFlags&lt;/code&gt; 时其 flags 前的参数也是 0，我不知道为什么还保留 pymain_run_repl 的原因是什么，是为了向后兼容吗？欢迎和我交流你的想法～。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Guido van Rossum &lt;a href=&#34;https://paper.dropbox.com/doc/Yet-another-guided-tour-of-CPython-XY7KgFGn88zMNivGJ4Jzv&#34;&gt;Yet another guided tour of CPython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Louie Lu &lt;a href=&#34;https://hackmd.io/@klouielu/ByMHBMjFe?type=view&#34;&gt;A guide from parser to objects, observed using GDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Anthony Shaw &lt;a href=&#34;https://realpython.com/cpython-source-code-guide/#establishing-runtime-configuration&#34;&gt;Your Guide to the CPython Source Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devguide.python.org/internals/exploring/&#34;&gt;Python devguide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devguide.python.org/internals/compiler/&#34;&gt;Python&amp;rsquo;s Compiler design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://peps.python.org/pep-0432/&#34;&gt;PEP 432&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://peps.python.org/pep-0587/&#34;&gt;PEP 587&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>智慧川大人 ｜ 凤凰浴火，涅槃重生——软件学院辩论队进入凤展决赛</title>
      <link>https://forceoflife.cn/zh-cn/post/bldbjszb/</link>
      <pubDate>Wed, 08 Nov 2023 11:31:10 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/bldbjszb/</guid>
      
      <description>&lt;p&gt;11月5日，“凤凰展翅”2023年文化艺术节”智慧川大人“辩论赛的半决赛在我校江安校区拉开帷幕。其中，我院辩论队作为反方，与机械工程学院辩论队的同学们针对“当AI担任竞技辩论评委”的利弊比较展开了激烈的讨论，最终以12 : 3大比分战胜了对手，挺进决赛。&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
    &lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/%E8%B5%9B%E5%9C%BA.jpeg&#34; width=&#34;50%&#34; height=&#34;50%&#34;&gt;
    &lt;p style=&#34;text-align: center&#34;&gt;图1 赛场合照&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;针对此次辩题，我院辩论队充分发挥自身优势，将AI的能力与竞技辩论发展的矛盾描摹地淋漓尽致；不但如此，他们还从辩论的起源出发，认为辩论是说服人的艺术，这其中不能缺少人的参与，充分体现了新时代工科学生的人文关怀。&lt;/p&gt;
&lt;p&gt;值得一提的是，这是我院辩论队3年内第2次杀入“凤凰展翅”辩论赛的决赛，在2021年，我院辩论队就由19级和20级学长学姐打入决赛，最终负于化学工程学院辩论队，屈居亚军。但是，他们没有沉溺于失败的苦痛中不能自拔，而是重整旗鼓，誓要拿回曾经丢掉的荣耀。经过一年的蛰伏，今年的他们以“此去泉台招旧部，旌旗十万斩阎罗”的气魄，小组赛力克轻工科学与工程学院、文学与新闻学院，从死亡小组中杀出一条血路；四分之一决赛中，大比分连克匹兹堡学院与化学学院；在半决赛中，又以无可匹敌之姿拿下对手，再次挺进决赛。凤凰浴火，涅槃重生；凤凰展翅，一飞冲天。&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
    &lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/image-20231108112705952.png&#34; width=&#34;75%&#34; height=&#34;75%&#34;&gt;
    &lt;p style=&#34;text-align: center&#34;&gt;图2 软件学院辩论队&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我院辩论队是一支具有优良传统的队伍，也是一支具有光辉历史的队伍，更是一支富有使命的队伍。“一身转战三千里，一剑曾当百万师”，“凤凰展翅”辩论赛，他们3年2进决赛；“学院杯”辩论赛，他们连续6年挺进8强，是川大辩论圈的传统强队。在传承与发展上，他们秉承着以老带新的准则，每次比赛都会有高年级学长、学姐与上场的辩手一同准备。对于新生力量的培养，他们坚决贯彻理论与实际、队训与实战相结合的思想，以赛代练、以练促学，逐渐形成了一套行之有效的培养方案。同时，他们还是一支精诚团结的队伍。当队员遇到困难，大家总会尽力帮助，不论是学习还是生活。临近半期考试，22级的大家忙于复习，半决赛人手紧缺，于是便有21级的同学紧急顶上，成为挺进决赛的最后一步助力。&lt;/p&gt;
&lt;p&gt;“萧瑟秋风今又是，换了人间”，如今，决赛的对手是同样强大，一路从死亡半区中杀出的公共管理学院辩论队。希望我们的辩手们能够用更强的斗志，以“明敕星驰封宝剑，辞君一夜取楼兰”的姿态，拿下一座属于软件学院的奖杯。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>围炉夜话（4）</title>
      <link>https://forceoflife.cn/zh-cn/post/wlyh4/</link>
      <pubDate>Sun, 29 Oct 2023 07:32:15 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/wlyh4/</guid>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这个系列许久没有续集了，由于内心感受的不同使得围炉夜话的质量也总是参差不齐，时而深刻，时而通俗。之前探讨时间流逝的一篇就较为深刻，而这一篇恐怕又要回到了去年的水平了（或许高水平才是偶一为之吧哈哈）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自开学以来还没写过什么好文章，本来是有很多内容想写的，可惜由于各种各样的原因一直没有动笔，今天索性借著凤展比赛前难以入眠的晚上一口气写完罢。&lt;/p&gt;
&lt;h2 id=&#34;年年岁岁花相似岁岁年年人不同&#34;&gt;年年岁岁花相似，岁岁年年人不同&lt;/h2&gt;
&lt;p&gt;去年凤展的时候，我开启了这个系列，快一年的时间只写了三篇，不能不令我汗颜。重新阅读去年写的内容，里面充斥著我对辩论复杂的情感。彼时我恐怕不会想到，如今我竟然又在凤展时写作这个系列的文章。只是就如这个标题所言，生活早已物是人非……&lt;/p&gt;
&lt;h3 id=&#34;总有人风华正茂&#34;&gt;总有人风华正茂&lt;/h3&gt;
&lt;p&gt;之前我在一篇日记里这样写道：“没有花永远开放，却总有人风华正茂，正如盛开的花朵下总有泥土支撑……”。最近正值学校申报大创，看着新一批的学弟学妹前仆后继地申报大创，溢出屏幕的热情不禁让我想起去年此时。当时正值凤展，一壁和两个口腔的同学琢磨交叉学科的申报，一壁想着搞一搞强化学习编译器，可最后都成了空。不仅如此，我整个学期都浑浑噩噩，最后不仅离散缺考挂科，还抑郁了一段时间，当时的影响如今也未必全数消除。如今，已入大三的我不再像大二伊始时那般风华正茂，只待一阵风来便扶摇直上、挥斥方遒，而必须要为将来考虑了；可是总会有一批又一批的人，继续在这片土地起舞、辩论、学习、生活，一如我去年模样……&lt;/p&gt;
&lt;h3 id=&#34;何妨停留在此间&#34;&gt;何妨停留在此间&lt;/h3&gt;
&lt;p&gt;昨天和小孩们磨完辩，我和小殷姐、杨队一起去外面吃东西。我没有吃饭，小殷姐有点饿，杨队则是完全不饿。其实原本只会有我一个的，因为那时小殷姐说西南门出去有些远，不想去了，只是杨队说可zzx没有吃晚饭，便都去了。说来奇怪，上一次类似的时间类似的人，可能也要追溯到去年现在了，人总是会两次踏进同一条河流呢，呵呵^_^。因为路途有些距离，我们便聊了点东西。从这次凤展到上次凤展，从现在到以前，不知为何，没有人去聊未来，最多只是他们说如果有机会的话想看我再打一次凤展。很难说我现在对凤展，或者说是辩论的态度，毕竟去年的我确乎是发过誓说不再上辩论场，虽然上学期参加了夏日辩论赛，但那毕竟是娱乐赛，更多是想和杨队小殷姐再打一次，和凤展是迥乎不同的，我总是被自己的情感所控制，而不是控制自己的情感。&lt;/p&gt;
&lt;p&gt;到了菜市场那边，于烧烤摊的塑料椅上坐定，三人反倒没什么话了，兀自吃着、看着，相顾无言。夜空很黑，灯光很亮，四周很吵，我们很静，有一丝尴尬，但静好更多些。我们总会希望时间停留在某些时刻，或是久旱甘霖，或是金榜题名，或是偶遇故知，或是双亲当年，若说此时于我，则又何妨此间。在去年的文章里我写过，当时的我害怕我和小殷姐、杨队、峰峰哥他们的缘分止于辩论。又过了一年，回过头来看，辩论依然是我们交流的主要，但也多了许多之前没有的东西，也许是随着年级的升高，都必须为未来让渡罢。曾经那个无所不能的学姐，也会在保研前焦虑发疯；曾经那个意气风发的辩论少年，也要在考研面前偃旗息鼓；曾经踌躇满志的我，也决定放弃出国走向社会。学姐已经保研高就，学长即将走向考场，我还有两年时间，再见为时尚早，再聚机会很多，只是不知下次会以何种身份境遇，教我如今再说，不如缘分之中永远有辩论，还会互相说服彼此，毕竟，欲买桂花同载酒，终不似，少年游……&lt;/p&gt;
&lt;h2 id=&#34;世事洞明皆学问人情练达即文章&#34;&gt;世事洞明皆学问，人情练达即文章&lt;/h2&gt;
&lt;p&gt;最近我做了一个重要的决定，放弃出国的计划，一心准备就业。相信每个初听这个决定的人都会感到震惊，前两年的我是那么汲汲于留学，羡慕于国外宽松、开放的学习环境，如今决定放弃不得不说是个大胆而决绝的决定。&lt;/p&gt;
&lt;h3 id=&#34;缘起社会加速&#34;&gt;缘起社会加速&lt;/h3&gt;
&lt;p&gt;在准备第一轮凤展的时候，我看了德国著名社会科学家哈特穆特·罗萨的两本书《新异化的诞生——社会加速批判理论大纲》、《加速——现代社会中时间结构的改变》，了解了他的社会加速理论。他在这本书里提出，从前现代社会以来，我们的社会发展呈加速状态，由于科技加速，使得生活变迁加速，进而使得生活步调加速，生活步调加速又反作用于科技加速形成加速闭环，市场经济竞争逻辑主导下的人就像笼子中的仓鼠一样不停加速奔跑，生活质量却每况愈下。&lt;/p&gt;
&lt;p&gt;这让我思考，我究竟想要些什么，我要怎样才会活得更快乐、更踏实。显然不是做科研，两年的学习让我发现，相比于读论文、做科研，我更喜欢参与工程开发，和代码打交道。并且，我是一个地道的北方人，内蒙古的饮食和气候早已给我打上了深深的烙印，在成都都无法适应，遑论国外，只怕到时生不如死罢。&lt;/p&gt;
&lt;p&gt;罗萨在《异化》书中用批判理论对社会加速进行批判，提到社会加速会异化我们的行为，让我们多做许多必须要做但不想做的事情，从而让我们没有时间做真正想做的事。为了出国读书，最好要准备些项目丰富自己的简历，例如大创、科研，可我并不喜欢做这些，更不喜欢为了提升自己而做有害于自己提升的事，这些就是罗萨理论中“异化”的部分，也因此，我开始思考放弃出国留学。&lt;/p&gt;
&lt;h3 id=&#34;终于现实桎梏&#34;&gt;终于现实桎梏&lt;/h3&gt;
&lt;p&gt;上面写的只是激起我放弃出国想法的诱因，而真正让我下定决心放弃出国的是现实的因素。我并不打算做科研，也因此不会申请phd，就算要留学也只会去读一年左右的授课型硕士，可是这种硕士是不会教什么编译、系统相关课程的。换句话说，我只是花了一年时间去学习些工作用不上的内容。如果说这不需要花多少钱也就罢了，权当在学校再缓一年，家里条件也没有到需要我立刻挣钱的地步；只是去国外留学实在是价值不菲，学费生活费加起来就要40w左右，实在是一笔高价。虽然父母多半会支持我，但是我实在没有勇气花家里这么多钱去学习些用不到的内容。我也曾幻想过，如果我的家里非常富有，我可以本科就去美国接受全世界最好的计算机教育，或者说可以去学我高中时候最想学的数学或是文学，可惜这终究是黄粱一梦，人总要面对现实。&lt;/p&gt;
&lt;p&gt;对于工作，我第一想法是找一份在北方的工作，最好是在北京。一来北京一直是我魂牵梦萦之所，我对北京各方面的了解可以说是半个北京人；二来北京离家很近，如果有些什么变故不论是我赶回去还是父母赶过来都很方便；再次，北京的医疗条件可以说冠绝全国，万一有什么差错，有一个在北京的人总要比都从外地赶过去方便。我并不是想定居北京，或者说即使我想也没有那个能力，哈哈，相当长的一段时间，我的最终理想还是回到包头，住在那个阳光小区那个熟悉的两居室里，过着陌生而熟悉的生活。&lt;/p&gt;
&lt;p&gt;不论如何，在大三的开始，我打算放弃出国，面向就业了，也更加练达，更加坦荡了。&lt;/p&gt;
&lt;p&gt;—— 2023年10月29日，凌晨 6 : 57 ，于四川大学江安校区西苑宿舍&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>日记一则</title>
      <link>https://forceoflife.cn/zh-cn/post/dairy1015/</link>
      <pubDate>Sun, 15 Oct 2023 22:10:05 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/dairy1015/</guid>
      
      <description>&lt;p&gt;昨天喝了两瓶啤酒，多少有些上头，洗了个冷水澡迷迷糊糊就睡了，并没来得及记日记，不过今天没什么事，可以和昨天一并记。&lt;/p&gt;
&lt;p&gt;昨晚进行了凤展新一轮的比赛，我们赢了，或者是，他们赢了，他们出线了，这很让我感到高兴。一方面为他们高兴，另一方面也为自己高兴。&lt;/p&gt;
&lt;p&gt;为他们高兴是他们又一次证明了自己，证明了他们在 22 级辩论队里的实力是不俗的。这一次凤展他们的表现不像我们去年一样狼狈出局，也不像学院杯那样充满遗憾（虽然凤展还没有结束），他们的对手很强，但他们仍然赢了，赢得很漂亮，第二场甚至是近乎碾压，他们的未来还在继续，他们的未来还能继续。&lt;/p&gt;
&lt;p&gt;为我高兴的是，我也证明了自己。这次比赛我付出了很多，甚至比去年付出的还要多。他们劣势持方出论无门，我连夜看完了罗萨的《新异化的诞生》，拿出了一个不错的框架，最终帮助他们在劣势持方艰难地战胜了对手；他们的几乎每场比赛我都到场，晚上为他们复盘、理清战术，最重要的是，顶住压力、力排众议，坚持改革，推进备赛节奏，让他们尽早回去休息，保证相对健康的作息和良好的精神状态迎接比赛，而不是像去年的我一样感觉早死早超生。&lt;/p&gt;
&lt;p&gt;相比于去年凤展行尸走肉的自己，今年的我更像一位教练员，或者说指挥员。我的实力远在去年之上，对辩论的理解也超过去年太多，只是今年的我，却连坐在教室里看凤展的勇气都没有了。&lt;/p&gt;
&lt;p&gt;是的，虽然很难承认，但去年的凤展确实给我造留下了心理阴影，甚至造成了心理创伤，我不再敢去看凤展的比赛了。并且，学习与生活让我只能远离那个我花了很多时间的地方，或许我还能打，但我已经“不能”再打了，属于我的辩论生涯几乎已经可以盖棺定论了。&lt;/p&gt;
&lt;p&gt;用今天凌晨写的一句话，作为对他们的祝福，也作为给自己的写照，同样是这篇日记的结尾吧：&lt;/p&gt;
&lt;p&gt;“没有花永远开放，却总有人风华正茂，正如盛开的花朵下总有泥土支撑……”&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>一场面试引发的思考</title>
      <link>https://forceoflife.cn/zh-cn/post/liveincollege/</link>
      <pubDate>Wed, 20 Sep 2023 01:14:05 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/liveincollege/</guid>
      
      <description>&lt;p&gt;昨天本欲写一篇言辞犀利的文章来申斥，但今天想想还是算了。一来这不符合我一贯以来的风格，我素来偏好云淡风轻，润物细无声，何必为小小交换生而大动肝火；二来昨天晚上小朱姐说得对，面试本就是双向选择，他们不愿选我，我也瞧不上他们这项目哩。&lt;/p&gt;
&lt;h3 id=&#34;面试过程&#34;&gt;面试过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Q：做一下自我介绍&lt;/p&gt;
&lt;p&gt;A：既然没有限定范围，我就首先从爱好介绍起。我最大的爱好是文学和写作，平时得暇会看各宗书籍，包括散文、小说、社科等，同时我会把我的感想写下来发到博客上面去。我第二大爱好是欣赏中国的传统曲艺，比如相声、评书、京剧等，我也在公开场合的舞台上表演过这些内容。之后就是很多零碎的爱好，比如围棋业余三段，10 秒还原一个魔方，篮球，游泳等。&lt;/p&gt;
&lt;p&gt;我在大一代表学院辩论队参加学院杯辩论赛拿到 8 强，在大二又以软件学院辩论队队长的身份带领大一的同学拿到 8 强。&lt;/p&gt;
&lt;p&gt;我在计算机方向上喜欢的是编译原理，大致就是把人写的代码正确、高效地转换为机器可以识别、运行的 0、1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q：有没有参加过什么竞赛？&lt;/p&gt;
&lt;p&gt;A：参加过软件学院大一组织的院级大创，当时开发了一个小型的编译器，虽然不能投入工业使用，但是作为一个玩具或是学习的工具也是不错的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q：你目标学校是哪里？&lt;/p&gt;
&lt;p&gt;A：坦白讲，如果是让我选择研究生去哪里读，我会选择香港，港科技，因为那里是英联邦教育体系，在世界范围内认可度更高；但是现在让我选我会选台湾，因为相比于香港，台湾有更多的文化属性吸引我，我毕竟没有到生死存亡的关键时刻，此时还是可以随性选择的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q：那你总要有个目标学校吧？不然你之后转换学分你怎么做？&lt;/p&gt;
&lt;p&gt;A：好好好，我来告诉你我的目标学校嘛。对于香港，港科技；对于台湾，国立台湾师范大学和国立台湾科技大学。我看过它们相关专业开设的课程表，我下学期要选的编译原理和人工智能都在列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q：我听你这意思，好像你去交换是为了去体验生活和经历的？&lt;/p&gt;
&lt;p&gt;A：这就要提到我的两个选择交换的原因了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其一，我曾经看过一本书，叫《优秀的绵羊》，里面讲了美国的精英教育，分析了为什么他们的精英教育是失败的，又应该如何挽救。我在看的时候就觉得，好像在中国的四川大学，里面很多问题我也经历过。所以，我就想抓住各种机会，去感受一下不同的教育体制和这种体制下培养出的人。&lt;/li&gt;
&lt;li&gt;其二，计算机科学不同于其他学科，其开源的属性使得可以轻松获得各方面的知识，对于那些不能获得的知识，大多是公司的专利或私有软件，无论哪里都获取不到的。我在川大就可以听 Stanford、CMU 等世界顶级计算机高校的课程，所以在这样的情况下，交换就势必要有些不同的目的，否则就是得不偿失了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q：你觉得为什么川大会派你去？&lt;/p&gt;
&lt;p&gt;A：这个问题又要分两个层次，一个层次是，我个人区别于传统上对计算机工程人员的刻板印象，好像只能宅在屋子里些程序，而我更加热爱文学、生活，我有我区别于一般同学的独特特质，能很好地展现川大“海纳百川，有容乃大”的校训；第二个层次是，我希望它派我去，因为事实上不管派谁去，都是川大风采的展现，因为海纳百川，有容乃大，所以从宏观上派我或派别人并无太大区别，只是我有我想去的理由，我也有我独特的特质，所以我会希望川大可以派我去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;我见&#34;&gt;我见&lt;/h3&gt;
&lt;p&gt;这个面试本没有什么，但是里面却体现了很多让人难以理解的现象。昨晚我和小朱姐达成了一个共识，很多事情一到国内就会改变其原本的目的。我认为这不是一个或几个人造成的，而是长期以来，甚至从有这个民族以来就决定了的。我很难说那些参加面试的同学有什么问题，他们只是想给面试官展现最好的自己，所以才会精心准备自己的成果，才会投老师所好去讲一些场面话；我也不能说面试的老师有什么错，一来学校的考核就是这样，二来这种观念可能在他们的脑子里已经变得根深蒂固、不可动摇了；如果一定要说有错，那就是我有错了，错在不该多看了几本书就觉得现实和想象一样，不该天真地认为我的同学和老师们和我抱有相同的想法。毕竟，现实总是没错的，即使在理论上错了，那也是没错，因为你生存在现实里，是现实作用于你，而不是理论……&lt;/p&gt;
&lt;p&gt;先来看看交换生变成了什么罢。从我的观点来看，交换生存在的意义即是去到不同地区甚至国家的学校，去感受那里的学习环境、学习氛围，增加求学时代的经历；再往高层次讲一些，便是体验不同社会体制、教育体制下培养出的人的区别。可是现在的交换生，起码对于川大来说，并不是这样。他们好像更希望自己的学生派出去能力压群雄、艳盖群芳，希望让对方学校觉得，这个学校真厉害，培养出了这样优秀的人才。大多数同学也觉得，这是一个给他们简历增光添彩的经历，让他们在保研或申请时有更多的筹码。这样是错的吗，也未必，若社会的就业压力没有这么大，还会有这么多人如此吗？&lt;/p&gt;
&lt;p&gt;许多现在大学校园里种种不能理解的事，若从这个角度看，便都能理解了。读研究生的同学，当真知道自己想研究些什么吗？更不消说川大非常火爆的大创，就说计算机这方面，大多都是去问老师要项目，也不管自己感兴趣与否，更不论对自己有没有好处，凡是别人要做，我也要做。计算机本科能做的事情极其有限，做的事情应以打基础为主，而不是好高骛远地去搞什么人工智能、深度学习，最后沦为一个调包侠。如果你觉得我说的有失偏颇，不如细心观察一下，为什么大学里很少有大创是 PL 方向、系统方向、网络方向、软件工程方向？其实答案很简单，这些方向不是可以随便混一混学一学就能搞定的。其实人工智能也不是，但人工智能有人给你解决了困难的问题，你只需要会调包就可以。&lt;/p&gt;
&lt;p&gt;你也许还会说，那我也是创新了呀！呵，所谓的创新，不光要是做别人没做的事，还要求这件事有意义。看看我们所谓的大创吧，题目不尽相同，基于深度学习、基于神经网络，不就是找些没人动过的领域安上这些名头吗？真有创新，能应用在行业里吗？真正改变行业生态的产品，只消一个 demo 就能赢得投资人的信赖，而我们这些大创呢，结题之后恐怕连代码仓库都不会去碰罢！这样的创新非但不会发挥创新本应有的作用，反而会劣币驱逐良币，伤害真正想创新的人。川大一年大创一千多项，若都是创新，区区美国何足挂齿？这也是国内的一大特色，上面需要什么便一声令下，下面也不管不顾响应，反正有人口红利，总会有几个真正做出东西的人，这其实是一种高级的懒政、不作为。&lt;/p&gt;
&lt;p&gt;个人与环境，历来都是众说纷纭。一个很流行的说法是，为什么别人行你不行，环境要是有问题，别人是怎么成功的？还有一个流行的说法是，人不行别怪路不平。但我们很少真正去想，在一个错误的道路上走得很快，是什么值得夸耀的事情吗？难道离成功越来越远的人还应该被夸赞？我们一直有一种想法，黑猫白猫抓住耗子就是好猫，只要能挣大钱、有地位就行了，哪管之后洪水滔天，不得不说，这是一种短视，也是小民心理的最好体现。&lt;/p&gt;
&lt;p&gt;当然，纵使牢骚满腹，总是要回归现实的，如果改变不了的话，就努力离开吧……&lt;/p&gt;
&lt;p&gt;唉，本不应该写这种抱怨的文字……&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>从hexo到hugo</title>
      <link>https://forceoflife.cn/zh-cn/post/hexotohugo/</link>
      <pubDate>Sat, 09 Sep 2023 16:30:25 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/hexotohugo/</guid>
      
      <description>&lt;p&gt;没错，我从 hexo 迁移到了 hugo。这已经是我用过的第三个博客软件了，不出意外的话，短期内应该不会再更换了。&lt;/p&gt;
&lt;h2 id=&#34;更换理由&#34;&gt;更换理由&lt;/h2&gt;
&lt;p&gt;我的第一个博客软件是 &lt;code&gt;wordpress&lt;/code&gt;，是在看 &lt;code&gt;TheCW&lt;/code&gt; 的视频里知道的。当时正在上大一下的我还不懂什么是动态生成和静态生成，只知道 Wordpress 是一个被广泛使用的软件。当时用的还是 apache 服务器，而不是现在非常火的 nginx，就连安装也是通过宝塔一键完成的，基本谈不上任何技术含量。印象里并没有用那个软件发过一篇博客，只是配置了主题之后就搁置了。回想起来，动态生成的博客对于新手来说确实麻烦，当时只能在网页里写作，布局也没有配置文件，只能在网页里选择，或许当时放弃了也是一个值得庆幸的事。&lt;/p&gt;
&lt;p&gt;之后开始使用 hexo，不过这次并没有放在自己的服务器上。理由有几个，其一，服务器我只买了一年，后面续费的价格不低，我不一定会续费；其二，当时用 nginx 跑着自己的图书下载站和云笔记 docker，我对 nginx 并不熟悉；其三，如果部署到服务器，写博客就只能远程上去写，虽然也可以用 git、scp，但是仍然很麻烦……所以，最后选择了 GitHub pages，一直用到了现在。&lt;/p&gt;
&lt;p&gt;hexo 还是陪伴了我一段时间的，自打我用了 hexo，之前微信公众号的使用频率就降低了。我并不会把每一篇博文都转载到公众号去，只有当写了比较满意的文章才会发过去，毕竟公众号是真的会有人看，哈哈哈。我并没有像很多博客主一样对主题进行再加工，只是选择了一个比较火的 &lt;a href=&#34;https://ppoffice.github.io/hexo-theme-icarus/&#34;&gt;icarus&lt;/a&gt; 主题，对里面的控件位置进行了修改，加了评论和 Google Search 的支持。我在上面写了不少博文，其中有几篇我还是比较满意的，但 hexo 的一些问题也给我造成了许多困扰。&lt;/p&gt;
&lt;h3 id=&#34;nodejs&#34;&gt;NodeJS&lt;/h3&gt;
&lt;p&gt;hexo 是基于 nodejs 的，这对我非常不友好。我对于 web 领域一窍不通，平日几乎不会主动学习这方面的知识。所以对于诸如 &lt;code&gt;node_modules&lt;/code&gt;、&lt;code&gt;package.json &lt;/code&gt;等，我可谓是又想动又不敢动。而且，也不知道是不是因为 nodejs，每次更新博客要等很久才能生成，经常已经刷新到不耐烦了，新的内容才部署上去。&lt;/p&gt;
&lt;p&gt;其次，由于我对 nodejs 的不熟悉，导致我无法对主题进行改动，有些在本地实现的效果，一部署上去就失效了，令人费解。而且 hexo 用的 js 并不是标准的 js，而是一个修改过的框架，使得本就对前端知之甚少的我更加无所适从。&lt;/p&gt;
&lt;h2 id=&#34;hugo&#34;&gt;Hugo&lt;/h2&gt;
&lt;p&gt;其实我知道 hugo 和 hexo 的时间是差不多的，在我刚使用 hexo 时，就看到一位比较著名的知乎答主，&lt;a href=&#34;https://www.zhihu.com/people/skywind3000&#34;&gt;韦易笑&lt;/a&gt;的博客使用了 hugo。那时我并不知道 hexo 和 hugo 有甚区别，甚至觉得 hexo 是更先进的（并不是说 hugo 就更先进，只是那时无知），加之彼时还并未感受到 hexo 的问题，所以就选择了 hexo。&lt;/p&gt;
&lt;p&gt;前几天，当我为了 icarus 的几个效果而熬到很晚时，我便有了换一个软件的想法，第一时间就想到了 hugo。惭愧地说，促使我换到 hugo 的一大原因是我找到了我很喜欢的一个主题：&lt;a href=&#34;https://themes.gohugo.io/themes/hugo-octopress/#mainsections&#34;&gt;hugo-octopress&lt;/a&gt;，这个主题非常符合我的想法。其实之前在 hexo 也有一个我喜欢的主题：&lt;a href=&#34;https://jysperm.me/&#34;&gt;王子亭的博客 (jysperm.me)&lt;/a&gt;，但是我一直部署失败，不知为何。&lt;/p&gt;
&lt;p&gt;现在大部分博客主题都不符合我的审美，我个人审美非常复杂，经常出现矛盾的地方。我很喜欢上世纪 70-90 年代的那种简单甚至简陋的样子（简约这个词太现代而精致了，并不符合那个年代的风格），现在的绝大多数主题都是非常现代化的布局，颜色设计、对比度、模糊、毛玻璃等特效非常绚丽，但我却喜欢不起来；那些所谓复古的主题也不过是披着复古衣服的现代产品罢了。&lt;/p&gt;
&lt;p&gt;再加上有看到，hugo 基于 go 使得它有更快的生成速度，配置相对更明确等优点，我便下定决心迁移。实话说迁移也费了一番功夫，中文网的教程虽多，但不是过时，就是语焉不详。我查了一段时间才知道，如果要部署到 github pages，是要用两个仓库，一个存放根目录，一个存放 public，而不能像 hexo 一样用一个 git 插件就解决问题，不过用 git 手工生成倒是更符合我的习惯。最后花了大约半天的时间，搞定了所有的内容，成功部署了上去，并且重新解析了我的域名到这个新的博客。&lt;/p&gt;
&lt;h2 id=&#34;使用体验&#34;&gt;使用体验&lt;/h2&gt;
&lt;p&gt;刚换了没几天，所以没有什么深度的感受。最大的感觉就是掌控感变强了，之前由于对 nodejs 的不熟悉，导致改代码都不知道怎么改，而 hugo 似乎是使用了纯粹的 html + css + js，使得修改代码变得简单了。不过要吐槽的是，这个主题的代码质量实在不敢恭维，我几乎不敢相信这是一份开源出来的代码而不是为了赶时间外包的产物，不过我对 web 并不熟悉，也不敢随意修改，只能慢慢实践。&lt;/p&gt;
&lt;p&gt;总的来说，hugo 目前给我的体验还是很好的，配置上也比 hexo 要方便许多，整体看起来也更清爽，没有令我如鲠在喉的&lt;code&gt;node_modules&lt;/code&gt; 和 &lt;code&gt;package.json&lt;/code&gt;，之后要做的就是好好产出内容了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>围炉夜话（3）——我在怀念什么？</title>
      <link>https://forceoflife.cn/zh-cn/post/wlyh3/</link>
      <pubDate>Thu, 03 Aug 2023 00:22:41 +0800</pubDate>
      <author>Zhixiao-Zhang@outlook.com (Patrick)</author>
      <guid>https://forceoflife.cn/zh-cn/post/wlyh3/</guid>
      
      <description>&lt;div align=&#34;center&#34;&gt;
  &lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/C2EC9D52-9863-4245-A535-C46F44C82328.jpeg&#34; alt=&#34;屹立多年的信号站&#34; style=&#34;zoom:50%;&#34; /&gt;
  &lt;p style=&#34;text-align:center;&#34;&gt;图1 屹立多年的信号站&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;年年岁岁花相似，岁岁年年人不同。 ——《代悲白头翁》 刘希夷 唐&lt;/p&gt;
&lt;p&gt;谁道人生无再少？门前流水尚能西！休将白发唱黄鸡。 ——《浣溪沙·游蕲水清泉寺》 苏轼 宋&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上周三，在和 docker 斗争了一下午未果后，我觉得应该出去走一走了。自我放假回家以来，虽然时常出去散步，但大都是为了饭后消食或锻炼身体而已，路线也总是那么一条——从家里走到包钢一中，再绕一圈到吾悦广场去，最后回家。这条路线是很不错的，长短合适，路途上也有一些值得看的东西，但于我而言却始终少些感觉。这种感觉是难以名状的，每个人的“感觉”更不尽相同，而我的感觉来自回忆。&lt;/p&gt;
&lt;p&gt;为了寻找感觉，为了重逢记忆，我在吃下一颗抗过敏药后走出了家门。起初我仍旧是沿那条“老路线“走，当我走到包钢一中时，我并没有如往常一样改向南行，而是转向北，朝着记忆中熟悉的地方，向着儿时的我，缓缓走去……&lt;/p&gt;
&lt;p&gt;我首先经过的是一个不知名的广场，它和我上一个家只隔一条马路，小时候妈妈和姥姥会带我去那里玩；再长大些，我有了朋友，有了电视、电脑，有了功课，便很少去了。如今再次踏足这里，站在广场中央，扫视着周围那或熟悉或陌生的建筑与设施，仿佛还置身于十余年之前的这里。那时这里很新，广场周边也没有这么多的植被，只是一大片的水泥地，边缘每隔一段距离修建了一个树坛，后来，这里多了一些健身器材，儿时的我把这些当作上好的玩具，总是争抢着要玩一个我现在也不知道是做什么的仪器。&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
  &lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/7A3A3A3D-3A3D-4A3A-8A3A-3A3A3A3A3A3A.jpeg&#34; alt=&#34;儿时广场的健身器材&#34; style=&#34;zoom:75%;&#34; /&gt;
  &lt;p style=&#34;text-align:center;&#34;&gt;图2 儿时广场的健身器材&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这里陪伴我直到小学三年级的暑假，那时我在这里练习自行车，从最开始还有两个辅助轮的玩具车，慢慢骑上了我妈的女式车，最后即使骑我父亲的 26 车也完全没问题了。中间经历了怎么样的波折，发生了哪些故事，而今的我已经不记得了，唯一确定的是，自我学会骑自行车起，应该就很少来这里了。&lt;/p&gt;
&lt;p&gt;广场旁有一个酒店，大约也是在小学时修建的，当时也算一个比较有档次的地方了，家里亲戚的儿子圆锁时曾到这里吃过酒席。现今在看，当年崭新的装潢如今早已斑驳，曾经新潮的装修也随着彩板的老化与脱落而变得陈旧，泛黄的玻璃向路人诉说着它这些年的经历。&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
  &lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/27CEC0B3-D9F9-4CB9-A095-926F25AB5E7A_1_105_c.jpeg&#34; alt=&#34;兰亭酒店&#34; style=&#34;zoom:75%;&#34; /&gt;
  &lt;p style=&#34;text-align:center;&#34;&gt;图3 兰亭酒店&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;继续走，到了一处喷泉，印象里它应该好多年没有被使用过了。不过毕竟我已有 10 年上下没有来过了，中途是否还开启过就不得而知了，只是记忆中很早就不再喷了。在我还没上小学时，夏天的夜晚爸妈会带我来这里看喷泉，彼时我为那高高喷起、五彩斑斓的水柱所吸引，却被父母提醒说那里有电，不要靠太近。这段记忆确乎有些久远了，久远到我已记不得当时究竟与谁同行了；而我记住的，只是那时伴着水汽吹来的风，点缀着星星铺展的夜，和那段溢满童真的少年锦时。&lt;/p&gt;
&lt;p&gt;再往南走一些，透过高楼大厦与树叶之间的空隙看到的，是我的母校——包钢一中。这个角度的她，不是那个高中时每天要待十多小时的水泥建筑，而是那个小时候坐在父亲自行车后座上经过这里时一眼千年的佳人。那时道路两侧的树还没有这么高，那时周围还大多是沙地，那时父亲额头鬓角还未见斑白，那时……&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/E205E542-43CF-4289-B3AB-C575DC3A6840_1_105_c.jpeg&#34; alt=&#34;E205E542-43CF-4289-B3AB-C575DC3A6840_1_105_c&#34; style=&#34;zoom:75%;&#34; /&gt;
  &lt;p style=&#34;text-align:center;&#34;&gt;图4 包钢一中&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;之后便转头向我幼时住的小区走去，穿过一条向内的马路，便可看到小区的大门，门前在修路，我只得绕到路口过去。小区门口的底店很多都换了招牌，即使留下的也大多缩减店面或是增加业务，三年疫情改变了许多人的生活。从侧门进入小区，首先引起我注意的，就是路边的矮丛与灌木，较之我还在时茂密了不少，看来旧小区改造的步伐已经迈到了这里。虽然可以看出外墙保温几经重做，但房子总体的建筑风格仍保留了下来，旧友楼下停着的他那辆破自行车，初中我在搬走前存车的车棚，小时候最喜欢玩的秋千，楼前宽阔的停车坪与夹道，一切如故，却又历久弥新。&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
  &lt;img src=&#34;https://cdn.jsdelivr.net/gh/zzxdyf1314/mycloudimg@master/7CC9625D-61E9-43DF-811A-FB5950B1EF2E_1_105_c.jpeg&#34; alt=&#34;小区&#34; style=&#34;zoom:75%;&#34; /&gt;
  &lt;p style=&#34;text-align:center;&#34;&gt;图5 小区&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从小区中出来时天已渐黑，我也到了回家的时候。浸润在往日时光中的我有些低沉，兀自在思考一个问题——为什么我的感觉总在回忆与怀念中出现，抑或者，我在怀念什么？我总是在怀念，怀念课堂，怀念朋友，怀念故地，怀念记忆，甚至怀念一些比我年龄更长的东西。我在看老照片，听老故事时总是不自觉地代入自己，怀念那些年代，那些我并未经历的时光。是它们比如今更好吗？显然不是，中国近几十年来经济的增长速度与目共睹，我们的生活质量也显著提高；是那时的人更好吗？也不是，那时的人们连经济基础都没有保障，更遑论上层建筑了，许多人为了多挣钱不惜游走在黑白之间；是那时的生活承载着我的回忆吗？可很多时候我都没有在那里生活过……&lt;/p&gt;
&lt;p&gt;那是什么，是什么让我不断地怀念，究竟是什么？几天后，当我和父亲走在察素齐的街道上时，我找到了答案。在公布答案之前，先来想想我们现在的一天是怎么过的？早上起床，最快的速度梳洗打扮，吃过早饭赶去上课或上班，中午草草吃过饭又要继续上课、上班，晚上回去已然很晚了。到家一壁拆中午取的快递，一壁打开手机刷着购物网站或是社交软件。突然，几个朋友相约出去吃夜宵，你欣然应允，感到饭店后几个人扫码点单，一壁聊天吹牛一壁吃着菜，吃完后随机一个人在手机上结账，并发了一个群收款，回去时已经接近 12 点，简单洗漱完毕躺在床上，刷了一会儿手机定好闹钟沉沉睡去。这怎么了？&lt;/p&gt;
&lt;p&gt;这似乎没有什么问题，真的吗？随着科技的发展，生产力的解放，我们的生活也更加高效，得以把大部分时间都用在社会主义现代化建设上。空余时间在手机上轻松一点，需要的东西第二天就能送货到家，再也不需要赶去商场超市，甚至拿着票据去供销社或国营商场争抢那一两个名额；走入饭店，扫码点餐，没有了和服务员扯皮，没有了当着朋友翻菜单的尴尬；手机支付，实时到账，无须赶去银行，明码标价也无须讨价还价或是零钱不够，群收款也避免了挨个要账到窘迫。我们的生活高效而规律，每天几乎都在坐着同样的事情，就像工厂机器上的一个零件般尽职尽责，为社会主义现代化建设添砖加瓦。难道真的没少些什么吗？&lt;/p&gt;
&lt;p&gt;曾记得，爸妈带我去 106 买玩具时的激动与喜悦；曾记得，在服务员的推荐下点了一桌满意而经济的饭菜；曾记得，聚餐后大家争抢结账的场面以及大方抹零的小贩，这一幕幕，一桩桩，一件件，逐渐从我们的生活里悄无声息地退出，不带走一片云彩。可这些东西少了又怎样？我们似乎从来不觉得这有什么，我们乐于更高效地生活，这样我们可以做更多想做的事，赚更多的钱。似乎改变一点没什么影响，再多一些呢，再多一些呢？&lt;/p&gt;
&lt;p&gt;很难说这样的改变究竟是好是坏，生活方式与观念的改变是潜移默化的，只是当我完成一天的“任务”躺在床上时，也许会怀念那些没有“机器”、不缺“零件”的日子……&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
